<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5"><meta name="description" content="Java中的IO流概念介绍及使用方法，此IO只针对于磁盘IO，没有网络IO相关知识"><meta property="og:type" content="article"><meta property="og:title" content="IO流"><meta property="og:url" content="https://www.powercheng.fun/articles/fed4c017/index.html"><meta property="og:site_name" content="Caiden&#39;s Blog"><meta property="og:description" content="Java中的IO流概念介绍及使用方法，此IO只针对于磁盘IO，没有网络IO相关知识"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2021-10-27T13:51:37.000Z"><meta property="article:modified_time" content="2025-11-19T03:04:36.717Z"><meta property="article:author" content="Caiden Hou"><meta property="article:tag" content="Java"><meta property="article:tag" content="IO流"><meta name="twitter:card" content="summary"><link rel="shortcut icon" href="/images/favicon.ico"><link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="stylesheet" href="https://gw.alipayobjects.com/os/k/font/lxgwwenkaiscreenr.css"><title>IO流</title><link rel="stylesheet" href="/css/style.css"><link rel="alternate" href="/true" title="Caiden&#39;s Blog" type="application/atom+xml"><meta name="generator" content="Hexo 5.4.0"></head><body class="max-width mx-auto px3 ltr"><div id="header-post"><a id="menu-icon" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" aria-label="顶部" onclick='$("html, body").animate({scrollTop:0},"fast")' style="display:none"><i class="fa-solid fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">首页</a></li><li><a href="/archives/">文章</a></li><li><a href="/categories/">分类</a></li><li><a href="/search/">搜索</a></li><li><a href="/about/">关于</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" aria-label="上一篇" href="/articles/72268a5c/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle()' onmouseout='$("#i-prev").toggle()'></i></a></li><li><a class="icon" aria-label="下一篇" href="/articles/51ea15a6/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle()' onmouseout='$("#i-next").toggle()'></i></a></li><li><a class="icon" aria-label="返回顶部" href="#" onclick='$("html, body").animate({scrollTop:0},"fast")'><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle()' onmouseout='$("#i-top").toggle()'></i></a></li><li><a class="icon" aria-label="分享文章" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle()' onmouseout='$("#i-share").toggle()' onclick='return $("#share").toggle(),!1'></i></a></li></ul><span id="i-prev" class="info" style="display:none">上一篇</span> <span id="i-next" class="info" style="display:none">下一篇</span> <span id="i-top" class="info" style="display:none">返回顶部</span> <span id="i-share" class="info" style="display:none">分享文章</span></span><br><div id="share" style="display:none"><ul><li><a class="icon" target="_blank" rel="noopener external nofollow noreferrer" href="http://www.facebook.com/sharer.php?u=https://www.powercheng.fun/articles/fed4c017/"><i class="fab fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener external nofollow noreferrer" href="https://twitter.com/share?url=https://www.powercheng.fun/articles/fed4c017/&text=IO流"><i class="fab fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener external nofollow noreferrer" href="http://www.linkedin.com/shareArticle?url=https://www.powercheng.fun/articles/fed4c017/&title=IO流"><i class="fab fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener external nofollow noreferrer" href="https://pinterest.com/pin/create/bookmarklet/?url=https://www.powercheng.fun/articles/fed4c017/&is_video=false&description=IO流"><i class="fab fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=IO流&body=Check out this article: https://www.powercheng.fun/articles/fed4c017/" rel="external nofollow noreferrer"><i class="fa-solid fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener external nofollow noreferrer" href="https://getpocket.com/save?url=https://www.powercheng.fun/articles/fed4c017/&title=IO流"><i class="fab fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener external nofollow noreferrer" href="http://reddit.com/submit?url=https://www.powercheng.fun/articles/fed4c017/&title=IO流"><i class="fab fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener external nofollow noreferrer" href="http://www.stumbleupon.com/submit?url=https://www.powercheng.fun/articles/fed4c017/&title=IO流"><i class="fab fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener external nofollow noreferrer" href="http://digg.com/submit?url=https://www.powercheng.fun/articles/fed4c017/&title=IO流"><i class="fab fa-digg" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" href="http://www.tumblr.com/share/link?url=https://www.powercheng.fun/articles/fed4c017/&name=IO流&description=&lt;link rel=&#34;stylesheet&#34; type=&#34;text/css&#34; href=&#34;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&#34; /&gt;&lt;div class=&#34;.article-gallery&#34;&gt;&lt;p&gt;Java中的IO流概念介绍及使用方法，此IO只针对于磁盘IO，没有网络IO相关知识&lt;/p&gt;"><i class="fab fa-tumblr" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener external nofollow noreferrer" href="https://news.ycombinator.com/submitlink?u=https://www.powercheng.fun/articles/fed4c017/&t=IO流"><i class="fab fa-hacker-news" aria-hidden="true"></i></a></li></ul></div><div id="toc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#InputStream-OutputStream"><span class="toc-number">1.1.</span> <span class="toc-text">InputStream&#x2F;OutputStream</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reader-Writer"><span class="toc-number">1.2.</span> <span class="toc-text">Reader&#x2F;Writer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5"><span class="toc-number">1.3.</span> <span class="toc-text">同步和异步</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#File%E4%BD%BF%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text">File使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAFile%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.1.</span> <span class="toc-text">创建File对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#API"><span class="toc-number">2.2.</span> <span class="toc-text">API</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#InputStream%E4%BD%BF%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">InputStream使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%B4%E6%98%8E"><span class="toc-number">3.1.</span> <span class="toc-text">基本说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">3.2.</span> <span class="toc-text">使用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">3.3.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#OutputStream%E4%BD%BF%E7%94%A8"><span class="toc-number">4.</span> <span class="toc-text">OutputStream使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%B4%E6%98%8E-1"><span class="toc-number">4.1.</span> <span class="toc-text">基本说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#flush"><span class="toc-number">4.2.</span> <span class="toc-text">flush</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95-1"><span class="toc-number">4.3.</span> <span class="toc-text">使用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-1"><span class="toc-number">4.4.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#FilterStream"><span class="toc-number">5.</span> <span class="toc-text">FilterStream</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E4%BD%BF%E7%94%A8"><span class="toc-number">5.1.</span> <span class="toc-text">具体使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E5%AE%9A%E5%88%B6%E5%8C%96%E7%9A%84filterstream"><span class="toc-number">5.2.</span> <span class="toc-text">自己编写一个定制化的filterstream</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9Czip"><span class="toc-number">6.</span> <span class="toc-text">操作zip</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%B4%E6%98%8E-2"><span class="toc-number">6.1.</span> <span class="toc-text">基本说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E4%BD%BF%E7%94%A8-1"><span class="toc-number">6.2.</span> <span class="toc-text">具体使用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96ClassPath%E8%B5%84%E6%BA%90"><span class="toc-number">7.</span> <span class="toc-text">读取ClassPath资源</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%B4%E6%98%8E-3"><span class="toc-number">7.1.</span> <span class="toc-text">基本说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95-2"><span class="toc-number">7.2.</span> <span class="toc-text">使用方法</span></a></li></ol></li></ol></div></span></div><div class="content index py4"><article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle p-name" itemprop="name headline">IO流</h1><div class="meta"><div class="postdate"><time datetime="2021-10-27T13:51:37.000Z" class="dt-published" itemprop="datePublished">2021-10-27</time> (Updated: <time datetime="2025-11-19T03:04:36.717Z" class="dt-updated" itemprop="dateModified">2025-11-19</time>)</div><div class="article-category"><i class="fa-solid fa-archive"></i> <a class="category-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a></div><div class="article-tag"><i class="fa-solid fa-tag"></i> <a class="p-category" href="/tags/IO%E6%B5%81/" rel="tag">IO流</a>, <a class="p-category" href="/tags/Java/" rel="tag">Java</a></div></div></header><div class="content e-content" itemprop="articleBody"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery"><p>Java中的IO流概念介绍及使用方法，此IO只针对于磁盘IO，没有网络IO相关知识</p><span id="more"></span><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>IO就是input/output，这个是相对于内存而言的；</p><ol><li>iniput就是往内存里面放数据，数据从哪里来的呢？可以是本地磁盘，也可以是从网络获取的数据</li><li>output就是从内存里往外面传数据，数据要传到哪里去呢？可以是本地磁盘，也可以是网络</li></ol><p>IO是一种按照顺序读写的数据的模式，特点就是单向流动，就像自来水在水管里面流动一样，所以叫IO流</p><p>注意：InputStream流获取之后只能用一次，读取完了这个流就是空的了</p><h2 id="InputStream-OutputStream"><a href="#InputStream-OutputStream" class="headerlink" title="InputStream/OutputStream"></a>InputStream/OutputStream</h2><p>InputStream和OutputStream是以字节为单位读数据的，就是针对于字节流来做输入输出的，最小单位是byte，注意：nputStream/OutputStream这是两个抽象类</p><h2 id="Reader-Writer"><a href="#Reader-Writer" class="headerlink" title="Reader/Writer"></a>Reader/Writer</h2><p>Reader和Writer是以字符为单位读数据的，针对于字符数据来做输入输出很方便，底层其实还是字节数据，只不过加了一层字节转字符和字符转字节的转化，最小单位是char。注意：Reader/Writer是抽象类</p><h2 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h2><p>同步：读写IO代码时必须得等待数据返回后，才能执行后续代码，优点是代码编写简单，缺点是cpu利用率不足，InputStream/OutputStream和Reader/Writer都是同步IO</p><p>异步：读写IO时，仅仅发出请求，然后就可以执行后续代码了，优点是cpu利用率高，缺点是代码编写复杂</p><h1 id="File使用"><a href="#File使用" class="headerlink" title="File使用"></a>File使用</h1><p>java.io提供了File类来操作文件和目录</p><h2 id="创建File对象"><a href="#创建File对象" class="headerlink" title="创建File对象"></a>创建File对象</h2><p>File对象，创建的时候构造方法，可以传路径（相对/绝对），也可以传具体文件的路径（”D:\test.txt”），传目录就表示目录，传具体文件file就代表具体文件了，所以file对象可以表示目录，也可以表示文件</p><p>路径说明：</p><ol><li>传一个 “.” 代表的是当前目录，当前目录就是你的java项目的目录</li><li>传一个 “/“ 或 “\“ 就是表示的java项目所在磁盘的根目录</li><li>传一个 “..” 就是代表着上一级目录，也就是项目所属文件夹</li><li>也可以传绝对路径，就是表示的绝对路径目录</li><li>如果里面传的是具体文件file就是表示的具体文件，传目录就是表示的目录，file就是用来操作文件和目录的</li></ol><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><ul><li><p>创建File相关</p><ol><li>File file = new File(“..”); 构造方法</li><li>file.getAbsolutePath() 返回绝对路径</li><li>file.getPath() 返回创建file时传入构造方法的路径</li><li>file.getCanonicalPath() 返回规范路径</li><li>file.isFile() 是否是文件</li><li>file.isDirectory() 是否是做</li><li>File.separator 可以获取当前系统路径分隔符的表示符号，比如win是 “&quot; ,linux是 “/“</li></ol></li><li><p>file相关操作：判断 文件/目录 读写权限、创建删除 文件/目录</p><ol><li>file.canRead()：是否可读</li><li>file.canWrite()：是否可写</li><li>file.canExecute()：是否可执行，如果file是目录，canExecute代表就是是否可以列出它包含的文件夹和子目录</li><li>long length()：文件字节大小。</li><li>file.exists() 文件是否存在</li><li>file.createNewFile() 创建一个新文件</li><li>file.delete() 删除文件或目录，如果是目录的话，目录下必须为空才会删除</li><li>file.mkdir() 创建目录</li><li>file.mkdirs() 创建当前file对象表示的目录，如果父目录不存在也会把不存在的父目录创建出来</li></ol></li><li><p>遍历目录</p><ol><li><p>方式一：File[] listFiles = file.listFiles() 直接列出当前目录下的所有东西</p></li><li><p>方式二：通过new FileFilter()一个过滤器，过滤出自己想要的东西</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">File[] listFiles = file.listFiles(<span class="keyword">new</span> FileFilter() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File pathname)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 这里只列出目录下所有文件，不列出目录</span></span><br><span class="line">                <span class="keyword">return</span> pathname.isFile();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></li><li><p>方式三：方式二的lambda表达式写法：File[] listFiles1 = file.listFiles(File::isFile);</p></li></ol></li></ul><h1 id="InputStream使用"><a href="#InputStream使用" class="headerlink" title="InputStream使用"></a>InputStream使用</h1><h2 id="基本说明"><a href="#基本说明" class="headerlink" title="基本说明"></a>基本说明</h2><p>InputStream就是Java标准库提供的最基本的输入流，要特别注意的一点是，InputStream并不是一个接口，而是一个<strong>抽象类</strong>，它是所有输入流的超类。这个抽象类定义的一个最重要的方法就是int read()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><p>这个方法会读取输入流的下一个字节，并返回字节表示的int值（0~255）。如果已读到末尾，返回-1表示不能继续读取了。</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ul><li><p>普通读取，一个字节一个字节读取，效率低</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * InputStream基本使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">baseInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;d:\\\\test.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// read正常情况下返回的是读取的字节的int值(0-255)，如果读完了就返回-1</span></span><br><span class="line">        <span class="keyword">while</span> ( (n = inputStream.read()) != -<span class="number">1</span> ) &#123;</span><br><span class="line">            System.out.println(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 记得及时释放资源，不释放资源得话程序就会一直占用着资源</span></span><br><span class="line">        <span class="keyword">if</span> (inputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用try(resources) 这种方式会自动释放资源，也就是编译器会自己添加finally块调用close方法</span></span><br><span class="line">    <span class="keyword">try</span> ( InputStream inputStream1 = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;d:\\\\test.txt&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">while</span> ( (n = inputStream1.read()) != -<span class="number">1</span> ) &#123;</span><br><span class="line">            System.out.println(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用缓冲区读取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 普通的read方法一次读取一个字节，这样读取效率太低</span></span><br><span class="line"><span class="comment"> * 现在搞一个缓冲区来读取，就是一次性读取多个字节到缓冲区，对于文件和网络流来说，利用缓冲区一次性读取多个字节的效率不错</span></span><br><span class="line"><span class="comment"> * InputStream有两个重载方法来支持读取多个字节</span></span><br><span class="line"><span class="comment"> * int read(byte[] b)：读取若干字节并填充到byte[]数组，返回读取的字节数</span></span><br><span class="line"><span class="comment"> * int read(byte[] b, int off, int len)：指定byte[]数组的偏移量和最大填充数，这个偏移量是针对byte数据来说的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (InputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;d:\\\\test.txt&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// 定义一个1000个字节的缓冲区</span></span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1000</span>];</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">while</span> ( (n = inputStream.read(buffer)) != -<span class="number">1</span> ) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;read &quot;</span> + n + <span class="string">&quot; bytes&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>read方法是阻塞的，意思就是必须得等read这个方法执行完之后才能执行后面的代码，因为读取IO流相比执行普通代码，速度会慢很多，因此，无法确定read()方法调用到底要花费多长时间。</li><li>实际上，InputStream也有缓冲区。例如，从FileInputStream读取一个字节时，操作系统往往会一次性读取若干字节到缓冲区，并维护一个指针指向未读的缓冲区。然后，每次我们调用int read()读取下一个字节时，可以直接返回缓冲区的下一个字节，避免每次读一个字节都导致IO操作。当缓冲区全部读完后继续调用read()，则会触发操作系统的下一次读取并再次填满缓冲区。</li><li>这个IO流里read和write的重载方法说明【重要】</li></ol><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://blog.csdn.net/yancychas/article/details/68926121">教你完全理解IO流里的read和write</a></p><h1 id="OutputStream使用"><a href="#OutputStream使用" class="headerlink" title="OutputStream使用"></a>OutputStream使用</h1><h2 id="基本说明-1"><a href="#基本说明-1" class="headerlink" title="基本说明"></a>基本说明</h2><p>和InputStream类似，OutputStream也是抽象类，它是所有输出流的超类。这个抽象类定义的一个最重要的方法就是void write(int b)，签名如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> b)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><p>这个方法会写入一个字节到输出流。要注意的是，虽然传入的是int参数，但只会写入一个字节，即只写入int最低8位表示字节的部分（相当于b &amp; 0xff）。</p><p>和InputStream类似，OutputStream也提供了close()方法关闭输出流，以便释放系统资源。要特别注意：OutputStream还提供了一个flush()方法，它的目的是将缓冲区的内容真正输出到目的地。</p><h2 id="flush"><a href="#flush" class="headerlink" title="flush"></a>flush</h2><p>为什么要有<code>flush()</code>？因为向磁盘、网络写入数据的时候，出于效率的考虑，操作系统并不是输出一个字节就立刻写入到文件或者发送到网络，而是把输出的字节先放到内存的一个缓冲区里（本质上就是一个<code>byte[]</code>数组），等到缓冲区写满了，再一次性写入文件或者网络。对于很多IO设备来说，一次写一个字节和一次写1000个字节，花费的时间几乎是完全一样的，所以<code>OutputStream</code>有个<code>flush()</code>方法，能强制把缓冲区内容输出。</p><p>通常情况下，我们不需要调用这个<code>flush()</code>方法，因为缓冲区写满了<code>OutputStream</code>会自动调用它，并且，在调用<code>close()</code>方法关闭<code>OutputStream</code>之前，也会自动调用<code>flush()</code>方法。</p><h2 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h2><ul><li><p>普通写入：write(byte[]) / write(int n) / write(byte[], off, len)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * OutputStream基础使用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">baseUse</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    OutputStream outputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;d:\\\\test.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 如果test.txt里面有值的话就会把内容覆盖掉！</span></span><br><span class="line">    <span class="comment">// 和read一样，write也有三个方法，都是类似的</span></span><br><span class="line">    <span class="comment">// write(byte[]) / write(int n) / write(byte[], off, len)</span></span><br><span class="line">    outputStream.write(<span class="string">&quot;覆盖内容&quot;</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">    <span class="comment">// 事实上，如果写入数据得话，会先写入缓冲区，然后攒的差不多了，才会将缓冲区内容真正写进磁盘，做一次磁盘IO</span></span><br><span class="line">    <span class="comment">// flush就是强制将缓冲区中的内容刷进磁盘，不过close方法调用时也会将缓冲区的内容刷进磁盘</span></span><br><span class="line">    <span class="comment">// 其实read的时候也有缓冲区，先读若干个字节到缓冲区，再执行接下来的read方法</span></span><br><span class="line">    outputStream.flush();</span><br><span class="line">    outputStream.close();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建议使用try(resources)方式来操作，编译器会帮我们在finally块中进行close操作~</span></span><br><span class="line">    <span class="keyword">try</span>(OutputStream outputStream1 = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;d:\\\\test.txt&quot;</span>)) &#123;</span><br><span class="line">        outputStream1.write(<span class="string">&quot;hello world!&quot;</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h2><p>注意flush方法的使用</p><h1 id="FilterStream"><a href="#FilterStream" class="headerlink" title="FilterStream"></a>FilterStream</h1><p>这个是干嘛的：当我们需要inputstream具有很多功能的时候，比如需要带缓冲，计算签名功能，我们不能搞出来多个子类继承inputstream然后再操作，所以就有了这个</p><h2 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h2><p>当我们需要给一个“基础”<code>InputStream</code>附加各种功能时，我们先确定这个能提供数据源的<code>InputStream</code>，因为我们需要的数据总得来自某个地方，例如，<code>FileInputStream</code>，数据来源自文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InputStream file =<span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.gz&quot;</span>);</span><br></pre></td></tr></table></figure><p>紧接着，我们希望<code>FileInputStream</code>能提供缓冲的功能来提高读取的效率，因此我们用<code>BufferedInputStream</code>包装这个<code>InputStream</code>，得到的包装类型是<code>BufferedInputStream</code>，但它仍然被视为一个<code>InputStream</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InputStream buffered =<span class="keyword">new</span> BufferedInputStream(file);</span><br></pre></td></tr></table></figure><p>最后，假设该文件已经用gzip压缩了，我们希望直接读取解压缩的内容，就可以再包装一个<code>GZIPInputStream</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InputStream gzip =<span class="keyword">new</span> GZIPInputStream(buffered);</span><br></pre></td></tr></table></figure><p>无论我们包装多少次，得到的对象始终是<code>InputStream</code>，我们直接用<code>InputStream</code>来引用它，就可以正常读取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────────────┐</span><br><span class="line">│GZIPInputStream          │</span><br><span class="line">│┌───────────────────────┐│</span><br><span class="line">││BufferedFileInputStream││</span><br><span class="line">││┌─────────────────────┐││</span><br><span class="line">│││   FileInputStream   │││</span><br><span class="line">││└─────────────────────┘││</span><br><span class="line">│└───────────────────────┘│</span><br><span class="line">└─────────────────────────┘</span><br></pre></td></tr></table></figure><p>上述这种通过一个“基础”组件再叠加各种“附加”功能组件的模式，称之为Filter模式（或者装饰器模式：Decorator）。它可以让我们通过少量的类来实现各种功能的组合，类似的，OutputStream也是以这种模式来提供各种功能：</p><h2 id="自己编写一个定制化的filterstream"><a href="#自己编写一个定制化的filterstream" class="headerlink" title="自己编写一个定制化的filterstream"></a>自己编写一个定制化的filterstream</h2><p>只需要继承FilterInputStream，即可，关键就是构造方法传入的是inputstream，所以可以进行各种包装（装饰）</p><h1 id="操作zip"><a href="#操作zip" class="headerlink" title="操作zip"></a>操作zip</h1><h2 id="基本说明-2"><a href="#基本说明-2" class="headerlink" title="基本说明"></a>基本说明</h2><p>明白一个概念，zipEntry，可以看作是一个zip包中的具体文件，也可以看作是目录，但是entry并不存储数据，读取数据或写入数据还是操作的ZipInputStream或ZipOutputStream对象</p><p>ZipInputStream和ZipOutputStream都是filterstream</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">┌───────────────────┐</span><br><span class="line">│    InputStream    │</span><br><span class="line">└───────────────────┘</span><br><span class="line">          ▲</span><br><span class="line">          │</span><br><span class="line">┌───────────────────┐</span><br><span class="line">│ FilterInputStream │</span><br><span class="line">└───────────────────┘</span><br><span class="line">          ▲</span><br><span class="line">          │</span><br><span class="line">┌───────────────────┐</span><br><span class="line">│InflaterInputStream│</span><br><span class="line">└───────────────────┘</span><br><span class="line">          ▲</span><br><span class="line">          │</span><br><span class="line">┌───────────────────┐</span><br><span class="line">│  ZipInputStream   │</span><br><span class="line">└───────────────────┘</span><br><span class="line">          ▲</span><br><span class="line">          │</span><br><span class="line">┌───────────────────┐</span><br><span class="line">│  JarInputStream   │</span><br><span class="line">└───────────────────┘</span><br></pre></td></tr></table></figure><h2 id="具体使用-1"><a href="#具体使用-1" class="headerlink" title="具体使用"></a>具体使用</h2><ul><li><p>创建zip文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将一个目录中的文件打包</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createZip</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 这里构造方法填的是目标目录，就是压缩包放的地方</span></span><br><span class="line">    <span class="keyword">try</span> (ZipOutputStream zip = <span class="keyword">new</span> ZipOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;d:\\\\test.zip&quot;</span>))) &#123;</span><br><span class="line">        <span class="comment">// 获取要打包的目录</span></span><br><span class="line">        File dir = <span class="keyword">new</span> File(<span class="string">&quot;d:\\\\test&quot;</span>);</span><br><span class="line">        File[] files = dir.listFiles();</span><br><span class="line">        <span class="keyword">if</span> (files != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">                <span class="comment">// 放入一个实体，new ZipEntry中如果传名字就是默认打包到zip的根目录下，若传相对路径，就打包到对应相对路径下，zip包是根目录</span></span><br><span class="line">                zip.putNextEntry(<span class="keyword">new</span> ZipEntry(file.getName()));</span><br><span class="line">                zip.write(getFileDataAsBytes(file));</span><br><span class="line">                zip.closeEntry();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取文件中的字节流</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> file File对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> byte[]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] getFileDataAsBytes(File file) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 神器，可以临时搞一个输出流存字节数据</span></span><br><span class="line">    ByteArrayOutputStream byteArrayOutputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">    <span class="keyword">try</span>(InputStream inputStream = <span class="keyword">new</span> FileInputStream(file)) &#123;</span><br><span class="line">        <span class="keyword">while</span> ( (length = inputStream.read(bytes)) != -<span class="number">1</span> ) &#123;</span><br><span class="line">						<span class="comment">// 只写入读取了的长度，因为可能读不满缓冲池，会存在空字节</span></span><br><span class="line">            byteArrayOutputStream.write(bytes, <span class="number">0</span>, length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> byteArrayOutputStream.toByteArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>读取zip文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取zip包中的文件数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readZip</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(ZipInputStream zip = <span class="keyword">new</span> ZipInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;d:\\\\test.zip&quot;</span>))) &#123;</span><br><span class="line">        ZipEntry entry;</span><br><span class="line">        <span class="comment">// 缓冲区读</span></span><br><span class="line">        <span class="keyword">byte</span>[] cache = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">// 存储读取出来的数据</span></span><br><span class="line">        ByteArrayOutputStream byteArrayOutputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        <span class="keyword">while</span> ( (entry = zip.getNextEntry()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;entryName: &quot;</span> + entry.getName());</span><br><span class="line">            <span class="keyword">if</span> (!entry.isDirectory()) &#123;</span><br><span class="line">                <span class="keyword">int</span> n;</span><br><span class="line">                <span class="keyword">while</span> ((n = zip.read(cache)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;read &quot;</span> + n + <span class="string">&quot; bytes&quot;</span>);</span><br><span class="line">                    byteArrayOutputStream.write(cache, <span class="number">0</span>, n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(byteArrayOutputStream);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="读取ClassPath资源"><a href="#读取ClassPath资源" class="headerlink" title="读取ClassPath资源"></a>读取ClassPath资源</h1><h2 id="基本说明-3"><a href="#基本说明-3" class="headerlink" title="基本说明"></a>基本说明</h2><p>classPath就是编译后的classes文件，相对路径就是相对于classes文件夹来说的，classes文件夹就是classPath的根目录 “/“ ，所以从这里获取文件也是有特殊的方法的，一行代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InputStream resourceAsStream = ClassPathDemo.class.getResourceAsStream(<span class="string">&quot;/default.properties&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="使用方法-2"><a href="#使用方法-2" class="headerlink" title="使用方法"></a>使用方法</h2><ul><li><p>基本使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * classPath文件基本读取</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">baseUse</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (InputStream resourceAsStream = ClassPathDemo.class.getResourceAsStream(<span class="string">&quot;/default.properties&quot;</span>)) &#123;</span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        properties.load(resourceAsStream);</span><br><span class="line">        System.out.println(properties.getProperty(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        System.out.println(properties.getProperty(<span class="string">&quot;age&quot;</span>));</span><br><span class="line">        System.out.println(properties.getProperty(<span class="string">&quot;gender&quot;</span>));</span><br><span class="line">        <span class="comment">// 使用过这个输入流之后，输入流resourceAsStream就是空了，下面再用这个流的话还需要重新获取，因为输入流只能用一次</span></span><br><span class="line">        <span class="keyword">byte</span>[] cache = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        ByteArrayOutputStream byteArrayOutputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        <span class="comment">// 一定要判空</span></span><br><span class="line">        <span class="keyword">if</span> (resourceAsStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> ( (length = resourceAsStream.read(cache)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 只往输出流中写入读取的字节长度，因为cache存在空字节问题</span></span><br><span class="line">                byteArrayOutputStream.write(cache, <span class="number">0</span>, length);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(byteArrayOutputStream);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>从classPath获取，从外部获取；场景：jar包里打进去默认的配置文件，也就是classPath中的，然后还有一个方法是可以获取外部配置文件，给用户自定义配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从classPath获取和从外部文件获取</span></span><br><span class="line">Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">props.load(inputStreamFromClassPath(<span class="string">&quot;/default.properties&quot;</span>));</span><br><span class="line">props.load(inputStreamFromFile(<span class="string">&quot;.conf.properties&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从classpath中获取配置文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> filePath 文件相对路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> InputStream</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> InputStream <span class="title">inputStreamFromClassPath</span><span class="params">(String filePath)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> ClassPathDemo.class.getResourceAsStream(filePath);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从外部文件获取配置文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> filePath 文件路径：相对/绝对</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> InputStream</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> FileNotFoundException FileNotFoundException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> InputStream <span class="title">inputStreamFromFile</span><span class="params">(String filePath)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(filePath);</span><br><span class="line">    <span class="comment">// 如果文件不存在就新建</span></span><br><span class="line">    <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;file &quot;</span> + filePath + <span class="string">&quot; is not exists!&quot;</span>);</span><br><span class="line">        <span class="keyword">boolean</span> success = file.createNewFile();</span><br><span class="line">        System.out.println(success ? <span class="string">&quot;文件创建成功！&quot;</span> : <span class="string">&quot;文件创建失败！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>var options;"undefined"!=typeof lightGallery&&(options={selector:".gallery-item"},lightGallery(document.getElementsByClassName(".article-gallery")[0],options))</script></div></article><div class="blog-post-comments"><div id="disqus_thread"><noscript>加载评论需要在浏览器启用 JavaScript 脚本支持。</noscript></div></div><div id="footer-post-container"><div id="footer-post"><div id="nav-footer" style="display:none"><ul><li><a href="/">首页</a></li><li><a href="/archives/">文章</a></li><li><a href="/categories/">分类</a></li><li><a href="/search/">搜索</a></li><li><a href="/about/">关于</a></li></ul></div><div id="toc-footer" style="display:none"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#InputStream-OutputStream"><span class="toc-number">1.1.</span> <span class="toc-text">InputStream&#x2F;OutputStream</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reader-Writer"><span class="toc-number">1.2.</span> <span class="toc-text">Reader&#x2F;Writer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5"><span class="toc-number">1.3.</span> <span class="toc-text">同步和异步</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#File%E4%BD%BF%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text">File使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAFile%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.1.</span> <span class="toc-text">创建File对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#API"><span class="toc-number">2.2.</span> <span class="toc-text">API</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#InputStream%E4%BD%BF%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">InputStream使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%B4%E6%98%8E"><span class="toc-number">3.1.</span> <span class="toc-text">基本说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">3.2.</span> <span class="toc-text">使用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">3.3.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#OutputStream%E4%BD%BF%E7%94%A8"><span class="toc-number">4.</span> <span class="toc-text">OutputStream使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%B4%E6%98%8E-1"><span class="toc-number">4.1.</span> <span class="toc-text">基本说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#flush"><span class="toc-number">4.2.</span> <span class="toc-text">flush</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95-1"><span class="toc-number">4.3.</span> <span class="toc-text">使用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-1"><span class="toc-number">4.4.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#FilterStream"><span class="toc-number">5.</span> <span class="toc-text">FilterStream</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E4%BD%BF%E7%94%A8"><span class="toc-number">5.1.</span> <span class="toc-text">具体使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E5%AE%9A%E5%88%B6%E5%8C%96%E7%9A%84filterstream"><span class="toc-number">5.2.</span> <span class="toc-text">自己编写一个定制化的filterstream</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9Czip"><span class="toc-number">6.</span> <span class="toc-text">操作zip</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%B4%E6%98%8E-2"><span class="toc-number">6.1.</span> <span class="toc-text">基本说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E4%BD%BF%E7%94%A8-1"><span class="toc-number">6.2.</span> <span class="toc-text">具体使用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96ClassPath%E8%B5%84%E6%BA%90"><span class="toc-number">7.</span> <span class="toc-text">读取ClassPath资源</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%B4%E6%98%8E-3"><span class="toc-number">7.1.</span> <span class="toc-text">基本说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95-2"><span class="toc-number">7.2.</span> <span class="toc-text">使用方法</span></a></li></ol></li></ol></div><div id="share-footer" style="display:none"><ul><li><a class="icon" target="_blank" rel="noopener external nofollow noreferrer" href="http://www.facebook.com/sharer.php?u=https://www.powercheng.fun/articles/fed4c017/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener external nofollow noreferrer" href="https://twitter.com/share?url=https://www.powercheng.fun/articles/fed4c017/&text=IO流"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener external nofollow noreferrer" href="http://www.linkedin.com/shareArticle?url=https://www.powercheng.fun/articles/fed4c017/&title=IO流"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener external nofollow noreferrer" href="https://pinterest.com/pin/create/bookmarklet/?url=https://www.powercheng.fun/articles/fed4c017/&is_video=false&description=IO流"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=IO流&body=Check out this article: https://www.powercheng.fun/articles/fed4c017/" rel="external nofollow noreferrer"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener external nofollow noreferrer" href="https://getpocket.com/save?url=https://www.powercheng.fun/articles/fed4c017/&title=IO流"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener external nofollow noreferrer" href="http://reddit.com/submit?url=https://www.powercheng.fun/articles/fed4c017/&title=IO流"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener external nofollow noreferrer" href="http://www.stumbleupon.com/submit?url=https://www.powercheng.fun/articles/fed4c017/&title=IO流"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener external nofollow noreferrer" href="http://digg.com/submit?url=https://www.powercheng.fun/articles/fed4c017/&title=IO流"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" href="http://www.tumblr.com/share/link?url=https://www.powercheng.fun/articles/fed4c017/&name=IO流&description=&lt;link rel=&#34;stylesheet&#34; type=&#34;text/css&#34; href=&#34;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&#34; /&gt;&lt;div class=&#34;.article-gallery&#34;&gt;&lt;p&gt;Java中的IO流概念介绍及使用方法，此IO只针对于磁盘IO，没有网络IO相关知识&lt;/p&gt;"><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener external nofollow noreferrer" href="https://news.ycombinator.com/submitlink?u=https://www.powercheng.fun/articles/fed4c017/&t=IO流"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li></ul></div><div id="actions-footer"><a id="menu" class="icon" href="#" onclick='return $("#nav-footer").toggle(),!1'><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> 菜单</a> <a id="toc" class="icon" href="#" onclick='return $("#toc-footer").toggle(),!1'><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> 目录</a> <a id="share" class="icon" href="#" onclick='return $("#share-footer").toggle(),!1'><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a> <a id="top" style="display:none" class="icon" href="#" onclick='$("html, body").animate({scrollTop:0},"fast")'><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a></div></div></div><footer id="footer"><div class="footer-left">Copyright &copy; 2021-2025 Caiden Hou</div><div class="footer-right"><nav><ul><li><a href="/">首页</a></li><li><a href="/archives/">文章</a></li><li><a href="/categories/">分类</a></li><li><a href="/search/">搜索</a></li><li><a href="/about/">关于</a></li></ul></nav></div></footer></div><link rel="preload" href="/lib/font-awesome/css/all.min.css" as="style" onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"></noscript><script src="/lib/jquery/jquery.min.js"></script><script src="/lib/clipboard/clipboard.min.js"></script><script type="text/javascript">$(function(){$(".highlight table").before('<span class="btn-copy tooltipped tooltipped-sw" aria-label="复制到粘贴板！"><i class="fa-regular fa-clone"></i></span>'),new ClipboardJS(".btn-copy",{text:function(e){return Array.from(e.nextElementSibling.querySelectorAll(".code")).reduce((e,t)=>e+t.innerText+"\n","")}}).on("success",function(e){e.trigger.setAttribute("aria-label","复制成功！"),e.clearSelection()})})</script><script src="/js/main.js"></script><script type="text/javascript">var disqus_shortname="caidens-blog";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}()</script></body></html>