<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5"><meta name="description" content="关于Java基础方面的总结，快四个月没写过Java了，回忆一下"><meta property="og:type" content="article"><meta property="og:title" content="Java基础总结篇"><meta property="og:url" content="https://www.powercheng.fun/articles/40d12ba0/index.html"><meta property="og:site_name" content="Caiden&#39;s Blog"><meta property="og:description" content="关于Java基础方面的总结，快四个月没写过Java了，回忆一下"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.powercheng.fun/articles/40d12ba0/DD7F9Dc728image-20220220163723386.png"><meta property="og:image" content="https://www.powercheng.fun/articles/40d12ba0/a4eeF8d5f5image-20220220173529345.png"><meta property="og:image" content="https://www.powercheng.fun/articles/40d12ba0/75FdaE5818image-20220220181401271.png"><meta property="og:image" content="https://www.powercheng.fun/articles/40d12ba0/81aa757D4Aimage-20220220205051843.png"><meta property="og:image" content="https://www.powercheng.fun/articles/40d12ba0/1AA3D9ba11image-20220220205235617.png"><meta property="og:image" content="https://www.powercheng.fun/articles/40d12ba0/B18E4F2bfbimage-20220223171325738.png"><meta property="og:image" content="https://www.powercheng.fun/articles/40d12ba0/eDBFbd0ECAimage-20220227173047677.png"><meta property="og:image" content="https://www.powercheng.fun/articles/40d12ba0/9ec4c2DD1Fimage-20220227174558415.png"><meta property="og:image" content="https://www.powercheng.fun/articles/40d12ba0/cd4D902bf3image-20220302150727651.png"><meta property="article:published_time" content="2022-02-20T07:50:47.000Z"><meta property="article:modified_time" content="2025-07-28T14:45:05.925Z"><meta property="article:author" content="Caiden Hou"><meta property="article:tag" content="Java"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://www.powercheng.fun/articles/40d12ba0/DD7F9Dc728image-20220220163723386.png"><link rel="shortcut icon" href="/images/favicon.ico"><link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="stylesheet" href="https://gw.alipayobjects.com/os/k/font/lxgwwenkaiscreenr.css"><title>Java基础总结篇</title><link rel="stylesheet" href="/css/style.css"><link rel="alternate" href="/true" title="Caiden&#39;s Blog" type="application/atom+xml"><meta name="generator" content="Hexo 5.4.0"></head><body class="max-width mx-auto px3 ltr"><div id="header-post"><a id="menu-icon" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" aria-label="顶部" onclick='$("html, body").animate({scrollTop:0},"fast")' style="display:none"><i class="fa-solid fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">首页</a></li><li><a href="/archives/">文章</a></li><li><a href="/categories/">分类</a></li><li><a href="/search/">搜索</a></li><li><a href="/about/">关于</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" aria-label="上一篇" href="/articles/3b4b1d9a/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle()' onmouseout='$("#i-prev").toggle()'></i></a></li><li><a class="icon" aria-label="下一篇" href="/articles/c46d8518/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle()' onmouseout='$("#i-next").toggle()'></i></a></li><li><a class="icon" aria-label="返回顶部" href="#" onclick='$("html, body").animate({scrollTop:0},"fast")'><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle()' onmouseout='$("#i-top").toggle()'></i></a></li><li><a class="icon" aria-label="分享文章" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle()' onmouseout='$("#i-share").toggle()' onclick='return $("#share").toggle(),!1'></i></a></li></ul><span id="i-prev" class="info" style="display:none">上一篇</span> <span id="i-next" class="info" style="display:none">下一篇</span> <span id="i-top" class="info" style="display:none">返回顶部</span> <span id="i-share" class="info" style="display:none">分享文章</span></span><br><div id="share" style="display:none"><ul><li><a class="icon" target="_blank" rel="noopener external nofollow noreferrer" href="http://www.facebook.com/sharer.php?u=https://www.powercheng.fun/articles/40d12ba0/"><i class="fab fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener external nofollow noreferrer" href="https://twitter.com/share?url=https://www.powercheng.fun/articles/40d12ba0/&text=Java基础总结篇"><i class="fab fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener external nofollow noreferrer" href="http://www.linkedin.com/shareArticle?url=https://www.powercheng.fun/articles/40d12ba0/&title=Java基础总结篇"><i class="fab fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener external nofollow noreferrer" href="https://pinterest.com/pin/create/bookmarklet/?url=https://www.powercheng.fun/articles/40d12ba0/&is_video=false&description=Java基础总结篇"><i class="fab fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=Java基础总结篇&body=Check out this article: https://www.powercheng.fun/articles/40d12ba0/" rel="external nofollow noreferrer"><i class="fa-solid fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener external nofollow noreferrer" href="https://getpocket.com/save?url=https://www.powercheng.fun/articles/40d12ba0/&title=Java基础总结篇"><i class="fab fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener external nofollow noreferrer" href="http://reddit.com/submit?url=https://www.powercheng.fun/articles/40d12ba0/&title=Java基础总结篇"><i class="fab fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener external nofollow noreferrer" href="http://www.stumbleupon.com/submit?url=https://www.powercheng.fun/articles/40d12ba0/&title=Java基础总结篇"><i class="fab fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener external nofollow noreferrer" href="http://digg.com/submit?url=https://www.powercheng.fun/articles/40d12ba0/&title=Java基础总结篇"><i class="fab fa-digg" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" href="http://www.tumblr.com/share/link?url=https://www.powercheng.fun/articles/40d12ba0/&name=Java基础总结篇&description=&lt;link rel=&#34;stylesheet&#34; type=&#34;text/css&#34; href=&#34;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&#34; /&gt;&lt;div class=&#34;.article-gallery&#34;&gt;&lt;p&gt;关于Java基础方面的总结，快四个月没写过Java了，回忆一下&lt;/p&gt;"><i class="fab fa-tumblr" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener external nofollow noreferrer" href="https://news.ycombinator.com/submitlink?u=https://www.powercheng.fun/articles/40d12ba0/&t=Java基础总结篇"><i class="fab fa-hacker-news" aria-hidden="true"></i></a></li></ul></div><div id="toc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">Java基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.1.</span> <span class="toc-text">基本类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.2.</span> <span class="toc-text">包装类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%B1%A0"><span class="toc-number">1.1.3.</span> <span class="toc-text">缓存池</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String"><span class="toc-number">1.2.</span> <span class="toc-text">String</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.2.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E5%95%A5%E8%A6%81%E6%8A%8AString%E6%90%9E%E6%88%90%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%EF%BC%9F"><span class="toc-number">1.2.2.</span> <span class="toc-text">为啥要把String搞成不可变的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String%E3%80%81StringBuffer%E3%80%81StringBuilder"><span class="toc-number">1.2.3.</span> <span class="toc-text">String、StringBuffer、StringBuilder</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-number">1.2.4.</span> <span class="toc-text">字符串常量池</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97"><span class="toc-number">1.3.</span> <span class="toc-text">运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%EF%BC%9AJava%E4%B8%AD%E5%8F%AA%E6%9C%89%E5%80%BC%E4%BC%A0%E9%80%92%EF%BC%8C%E6%B2%A1%E6%9C%89%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%EF%BC%81"><span class="toc-number">1.3.1.</span> <span class="toc-text">参数传递：Java中只有值传递，没有引用传递！</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.3.2.</span> <span class="toc-text">隐式类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#switch"><span class="toc-number">1.3.3.</span> <span class="toc-text">switch</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97-TODO"><span class="toc-number">1.4.</span> <span class="toc-text">关键字 TODO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#final"><span class="toc-number">1.4.1.</span> <span class="toc-text">final</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#static"><span class="toc-number">1.4.2.</span> <span class="toc-text">static</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this"><span class="toc-number">1.4.3.</span> <span class="toc-text">this</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.</span> <span class="toc-text">Object通用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%A7%88"><span class="toc-number">1.5.1.</span> <span class="toc-text">概览</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#equals"><span class="toc-number">1.5.2.</span> <span class="toc-text">equals()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashCode"><span class="toc-number">1.5.3.</span> <span class="toc-text">hashCode()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#toString-NaN"><span class="toc-number">1.5.4.</span> <span class="toc-text">toString()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#clone"><span class="toc-number">1.5.5.</span> <span class="toc-text">clone()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.5.5.1.</span> <span class="toc-text">浅拷贝</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.5.5.2.</span> <span class="toc-text">深拷贝</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">1.5.5.3.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">1.5.5.4.</span> <span class="toc-text">缺点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">1.6.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">1.6.1.</span> <span class="toc-text">访问修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%80%A7"><span class="toc-number">1.6.2.</span> <span class="toc-text">特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.6.3.</span> <span class="toc-text">抽象类和接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#super"><span class="toc-number">1.6.4.</span> <span class="toc-text">super</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%86%99%E5%92%8C%E9%87%8D%E8%BD%BD"><span class="toc-number">1.6.5.</span> <span class="toc-text">重写和重载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">1.7.</span> <span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="toc-number">1.7.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96Class%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.7.2.</span> <span class="toc-text">获取Class对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%87%E6%80%BB"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">汇总</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%9F%90%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E6%98%AF%E6%9F%90%E4%B8%AA%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.7.3.</span> <span class="toc-text">判断某个对象是否是某个类的实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Class%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.7.4.</span> <span class="toc-text">使用Class对象创建实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%9F%90%E4%B8%AA%E7%B1%BB%E7%9A%84%E6%89%80%E6%9C%89%E6%96%B9%E6%B3%95"><span class="toc-number">1.7.5.</span> <span class="toc-text">获取某个类的所有方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%B1%BB%E5%AD%97%E6%AE%B5%E4%BF%A1%E6%81%AF"><span class="toc-number">1.7.6.</span> <span class="toc-text">获取类字段信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.7.7.</span> <span class="toc-text">调用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">1.7.8.</span> <span class="toc-text">优缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">1.8.</span> <span class="toc-text">异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-2"><span class="toc-number">1.8.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97"><span class="toc-number">1.8.2.</span> <span class="toc-text">嵌套</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#finally"><span class="toc-number">1.8.3.</span> <span class="toc-text">finally</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">1.9.</span> <span class="toc-text">泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-3"><span class="toc-number">1.9.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-number">1.9.2.</span> <span class="toc-text">泛型方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-1"><span class="toc-number">1.9.3.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95%E4%B8%8E%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-number">1.9.4.</span> <span class="toc-text">泛型方法与可变参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%B8%8A%E4%B8%8B%E8%BE%B9%E7%95%8C"><span class="toc-number">1.9.5.</span> <span class="toc-text">泛型的上下边界</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.9.5.1.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8A%E8%BE%B9%E7%95%8C"><span class="toc-number">1.9.5.2.</span> <span class="toc-text">上边界</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8B%E8%BE%B9%E7%95%8C"><span class="toc-number">1.9.5.3.</span> <span class="toc-text">下边界</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%BE%97%E4%B8%8D%E8%AF%B4%E6%B3%9B%E5%9E%8B%E6%95%B0%E7%BB%84"><span class="toc-number">1.9.6.</span> <span class="toc-text">不得不说泛型数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.10.</span> <span class="toc-text">注解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.10.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E4%BB%A5%E5%81%9A%E4%BB%80%E4%B9%88"><span class="toc-number">1.10.2.</span> <span class="toc-text">可以做什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">1.10.3.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.10.4.</span> <span class="toc-text">元注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.10.5.</span> <span class="toc-text">常见注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-number">1.10.6.</span> <span class="toc-text">自定义注解的规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E4%BE%8B%E5%AD%90"><span class="toc-number">1.10.7.</span> <span class="toc-text">自定义注解例子</span></a></li></ol></li></ol></li></ol></div></span></div><div class="content index py4"><article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle p-name" itemprop="name headline">Java基础总结篇</h1><div class="meta"><div class="postdate"><time datetime="2022-02-20T07:50:47.000Z" class="dt-published" itemprop="datePublished">2022-02-20</time> (Updated: <time datetime="2025-07-28T14:45:05.925Z" class="dt-updated" itemprop="dateModified">2025-07-28</time>)</div><div class="article-category"><i class="fa-solid fa-archive"></i> <a class="category-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a></div><div class="article-tag"><i class="fa-solid fa-tag"></i> <a class="p-category" href="/tags/Java/" rel="tag">Java</a></div></div></header><div class="content e-content" itemprop="articleBody"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery"><p>关于Java基础方面的总结，快四个月没写过Java了，回忆一下</p><span id="more"></span><h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><p>八大基本类型</p><table><thead><tr><th>基本类型</th><th>占用空间（bit）</th><th>默认值</th><th>取值范围</th></tr></thead><tbody><tr><td>byte</td><td>8</td><td>0</td><td>[-2^7, 2^7-1]</td></tr><tr><td>char</td><td>(无符号)16</td><td>‘\u0000’</td><td>[0, 2^16-1]</td></tr><tr><td>short</td><td>16</td><td>0</td><td>[-2^15, 2^15-1]</td></tr><tr><td>int</td><td>32</td><td>0</td><td>[-2^31, 2^31-1]</td></tr><tr><td>float</td><td>32</td><td>0.0f</td><td>~</td></tr><tr><td>long</td><td>64</td><td>0L</td><td>[-2^63, 2^63-1]</td></tr><tr><td>double</td><td>64</td><td>0.0d</td><td>~</td></tr><tr><td>boolean</td><td>~</td><td>false</td><td>true / false</td></tr></tbody></table><p>boolean 只有两个值：true、false，可以使用 1 bit 来存储，但是具体大小没有明确规定。JVM 会在编译时期将 boolean 类型的数据转换为 int，使用 1 来表示 true，0 表示 false。<strong>JVM 支持 boolean 数组，但是是通过读写 byte 数组来实现的。</strong></p><h3 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h3><p>基本类型和包装类型对应表</p><p>注意：所有的包装类型都是final的，也就是不可继承</p><table><thead><tr><th>基本类型</th><th>包装类型</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table><p>基本类型都有包装类型，基本类型和包装类型之间的赋值使用自动装箱和拆箱来完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer x = <span class="number">2</span>;     <span class="comment">// 装箱 调用了 Integer.valueOf(2)</span></span><br><span class="line"><span class="keyword">int</span> y = x;         <span class="comment">// 拆箱 调用了 X.intValue()</span></span><br></pre></td></tr></table></figure><h3 id="缓存池"><a href="#缓存池" class="headerlink" title="缓存池"></a>缓存池</h3><p>Java中存在一个缓存池这个东西，就是当我们使用<code>valueOf</code>的时候，它会优先从缓存池中获取对象</p><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Integer a = Integer.valueOf(<span class="number">123</span>);</span><br><span class="line">Integer b = Integer.valueOf(<span class="number">123</span>);</span><br><span class="line">Integer c = <span class="keyword">new</span> Integer(<span class="number">123</span>);</span><br><span class="line">System.out.println(a == b);	<span class="comment">// true</span></span><br><span class="line">System.out.println(b == c); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">Integer d = Integer.valueOf(<span class="number">1234</span>);</span><br><span class="line">Integer e = Integer.valueOf(<span class="number">1234</span>);</span><br><span class="line">System.out.println(d == e); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>由此可见，确实是存在缓存池这个东西，并且这个还是有大小限制的，123行，但是1234就没在缓存池中</p><p>查看<code>valueOf</code>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>low</code>和<code>high</code>之间从缓存池中拿，其他情况直接<code>new</code>，这个<code>low</code>和<code>high</code>是多少呢？</p><a href="/articles/40d12ba0/DD7F9Dc728image-20220220163723386.png" class="gallery-item"><img src="/articles/40d12ba0/DD7F9Dc728image-20220220163723386.png" title="image-20220220163723386"></a><p><code>low</code>是-128，<code>high</code>是127，并且，缓存池最大值还是可以用jvm指定（<code>-XX:AutoBoxCacheMax=&lt;size&gt;</code>），并且他的逻辑是从指定的缓存池最大值和127取最大，也就是我们就算设置<code>high</code>为126，他的缓存池最大也是127。</p><p><strong>注意：1.8所有数值类缓存池中，只有Integer的缓存值上界可调！</strong></p><p>基本类型对应的缓冲池如下：</p><ul><li>boolean values true and false</li><li>all byte values</li><li>short values between -128 and 127</li><li>int values between -128 and 127</li><li>char in the range \u0000 to \u007F</li></ul><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>String被声明为final，因此不可继承。</p><p>java8中String内部使用char数组存数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java9更换为了字节数组，并且用coder来标志用的哪种编码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The identifier of the encoding used to encode the bytes in &#123;<span class="doctag">@code</span> value&#125;. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span> coder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>String中存具体数据的value数组被声明为了final，代表value不能引用其他数组了，并且String内部没有改变value数组的方法，所以可以保证String不可变。</p><h3 id="为啥要把String搞成不可变的？"><a href="#为啥要把String搞成不可变的？" class="headerlink" title="为啥要把String搞成不可变的？"></a>为啥要把String搞成不可变的？</h3><ol><li><p><strong>字符串池的需要</strong>：在Java中有一个字符串池，如果重复创建同一个字符串对象的话，第二次就会从字符串池里面找这个对象，然后返回此对象的引用地址，如果String要是可变的，那这个就不能用了，因为你正在引用的对象竟然可以在你不知道的情况下被更改…….</p><a href="/articles/40d12ba0/a4eeF8d5f5image-20220220173529345.png" class="gallery-item"><img src="/articles/40d12ba0/a4eeF8d5f5image-20220220173529345.png" title="image-20220220173529345"></a></li><li><p><strong>缓存哈希值</strong>：String的哈希值在Java中经常被使用，例如作为HashMap的key，不可变的特性可以让String只会算一遍哈希，然后后面再用就不用重复计算这个字符串的哈希了，提高效率，下面是存字符串哈希值的属性相关代码(Cache the hash code for the string)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>安全考虑</strong>：String 被广泛用作许多 java 类的参数，例如网络连接、打开文件等。如果 String 不是不可变的，则连接或文件将被更改，这可能会导致严重的安全威胁。</p></li><li><p><strong>线程安全</strong>：String 不可变性天生具备线程安全，可以在多个线程中安全地使用。</p></li></ol><h3 id="String、StringBuffer、StringBuilder"><a href="#String、StringBuffer、StringBuilder" class="headerlink" title="String、StringBuffer、StringBuilder"></a>String、StringBuffer、StringBuilder</h3><p>可变性</p><ol><li>String不可变</li><li>StringBuffer和StringBuilder可变</li></ol><p>线程安全</p><ol><li>String不可变，线程安全</li><li>StringBuffer内部使用synchronized进行同步，线程安全</li><li>StringBuilder线程不安全</li></ol><p>使用场景：</p><ol><li><p>如果字符串后续不会更改，就用String</p><p>注意：使用 String 进行逻辑操作相当慢，根本不建议使用，因为 JVM 将 String 转换为字节码中的 StringBuffer。大量开销被浪费在从 String 转换为 StringBuffer 然后再转换回 String 上</p></li><li><p>如果字符串有大量逻辑和操作，就是那种改来改去的，就要使用StringBuffer或StringBuilder了</p><ul><li>如果程序只能单线程访问，直接用StringBuilder效率高，因为没有加锁</li><li>如果程序可以多线程访问，用StringBuffer，线程安全</li></ul></li></ol><h3 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h3><p>在编译期间，所有字符串字面量都会加到字符串常量池中，也可以用<code>intern()</code>方法把运行期间的字符串加入常量池</p><p>啥是字面量：<code>String a = &quot;hello&quot;</code>，这个hello就是字面量，会加到常量池里面，重复创建返回都都是这个hello的引用</p><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">String b = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">String c = <span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">System.out.println(a == b); <span class="comment">// true</span></span><br><span class="line">System.out.println(a == c); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>在运行期间，可以用<code>intern()</code>方法：常量池如果存在这个字符串就返回引用，不存在就往常量池里放入再返回引用</p><a href="/articles/40d12ba0/75FdaE5818image-20220220181401271.png" class="gallery-item"><img src="/articles/40d12ba0/75FdaE5818image-20220220181401271.png" title="image-20220220181401271"></a><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">String b = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">String c = <span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">String d = <span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>).intern();</span><br><span class="line">System.out.println(a == b); <span class="comment">// true</span></span><br><span class="line">System.out.println(a == c); <span class="comment">// false</span></span><br><span class="line">System.out.println(a == d); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。</p><h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><h3 id="参数传递：Java中只有值传递，没有引用传递！"><a href="#参数传递：Java中只有值传递，没有引用传递！" class="headerlink" title="参数传递：Java中只有值传递，没有引用传递！"></a>参数传递：Java中只有值传递，没有引用传递！</h3><p>Java 的参数是以值传递的形式传入方法中，而不是引用传递，如果是以对象作为方法参数传入方法中，传的其实是对象的地址以值得形式传入方法中。</p><p><strong>其实，就是传值的时候把地址传进去了，里面那个参数指向了那个地址的对象，他可以修改对象本身的属性值，但是他不能改变外部的值的指向</strong></p><h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><p>Java不能隐式向下执行转型，因为会丢失精度，<code>+=</code>和<code>++</code>可以隐式向下转型</p><p><strong>float和double</strong></p><p>如1.1默认是double</p><a href="/articles/40d12ba0/81aa757D4Aimage-20220220205051843.png" class="gallery-item"><img src="/articles/40d12ba0/81aa757D4Aimage-20220220205051843.png" title="image-20220220205051843"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.1字面量是double类型</span></span><br><span class="line"><span class="keyword">float</span> a = <span class="number">1.1</span>;</span><br><span class="line"><span class="comment">// 需要加f表示</span></span><br><span class="line"><span class="keyword">float</span> a1 = <span class="number">1.1f</span>;</span><br><span class="line"></span><br><span class="line">a1 = a1 + <span class="number">1.1</span>;</span><br><span class="line"><span class="comment">// += 可以隐式的向下转换</span></span><br><span class="line">a1 += <span class="number">1.1</span>; <span class="comment">// 相当于a1 = (float) (a1 + 1.1);</span></span><br></pre></td></tr></table></figure><p><strong>short和int</strong></p><a href="/articles/40d12ba0/1AA3D9ba11image-20220220205235617.png" class="gallery-item"><img src="/articles/40d12ba0/1AA3D9ba11image-20220220205235617.png" title="image-20220220205235617"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果1小的话是可以转short，如果大数的话会提示数字过大无法赋值</span></span><br><span class="line"><span class="keyword">short</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">short</span> c = <span class="number">123456789</span>;</span><br><span class="line"><span class="comment">// 1 字面量是int</span></span><br><span class="line">b = b + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// += 或 ++ 可以隐式的向下转换</span></span><br><span class="line">b += <span class="number">1</span>; <span class="comment">// 相当于 b = (short) (b + 1);</span></span><br><span class="line">b++; <span class="comment">// 同上</span></span><br><span class="line">b = (<span class="keyword">short</span>) (b + <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>java7开始switch支持String类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">&quot;a&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (s) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;a&quot;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;b&quot;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;not found&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>switch 不支持 long、float、double，是因为 switch 的设计初衷是对那些只有少数几个值的类型进行等值判断，如果值过于复杂，那么还是用 if 比较合适。</p><h2 id="关键字-TODO"><a href="#关键字-TODO" class="headerlink" title="关键字 TODO"></a>关键字 TODO</h2><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>final修饰符一般用于基本类型（primitive）域，或不可变（immutable）类对象。</p><ol><li><p>声明数据</p><p>声明数据为<strong>常量</strong>，可以是<strong>编译时常量</strong>，也可以是在<strong>运行时被初始化后不能被改变的常量</strong>。</p><ul><li>对于基本类型（基本八个类型int、flot…），声明后数值不能改变</li><li>对于引用类型（对象），声明后不能改变引用，也就是不能再引用其他对象了，但是被引用的对象本身是可以修改的</li></ul></li><li><p>声明方法</p><p>声明方法，<strong>方法不能被子类重写</strong>。</p><p><strong>private 方法隐式地被指定为 final</strong>，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。</p></li><li><p>声明类</p><p>声明类，类不能被继承</p></li></ol><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><ol><li><p>修饰变量：静态变量</p><p>修饰变量是静态变量</p><ul><li>静态变量：又叫类变量，这个变量是属于类的，可以直接通过类名来访问，<strong>类的所有实例都共享静态变量</strong>，静态变量在内存中只存在一份</li><li>实例变量：每创建一个实例，就会创建一个实例变量，与实例共生死</li></ul></li><li><p>修饰方法：静态方法</p><p>静态方法在类加载的时候就存在了，不依赖于任何实例，所以静态方法必须有实现，也就是<strong>静态方法不能是抽象方法；</strong>并且，静态方法内部，<strong>只能访问静态字段和静态方法，方法中不能有this和super关键字</strong>，因为这俩关键字是和对象关联的。</p></li><li><p>静态代码块</p><p>可以用static加花括号，来声明一个静态代码块，这个<strong>只在类初始化的时候运行一次</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;static block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line">        Student student1 = <span class="keyword">new</span> Student();</span><br><span class="line">        Student student2 = <span class="keyword">new</span> Student();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果，只会输出一次static block</span></span><br><span class="line"><span class="keyword">static</span> block</span><br></pre></td></tr></table></figure></li><li><p>静态内部类</p><p>首先说普通内部类，普通内部类创建的时候，需要<strong>依赖外部类的具体实例对象才能创建：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClass</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非静态内部类不能通过类直接创建 OuterClass&#x27; is not an enclosing class</span></span><br><span class="line">OuterClass.InnerClass innerClass = <span class="keyword">new</span> OuterClass.InnerClass(); <span class="comment">// error</span></span><br><span class="line"><span class="comment">// 非静态内部类只能通过外部类的实例来创建</span></span><br><span class="line">OuterClass outerClass = <span class="keyword">new</span> OuterClass();</span><br><span class="line">OuterClass.InnerClass innerClass1 = outerClass.<span class="function">new <span class="title">InnerClass</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>而静态内部类，可以直接创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态内部类可以直接new，不需要依赖具体外部类实例</span></span><br><span class="line">OuterClass.StaticInnerClass staticInnerClass = <span class="keyword">new</span> OuterClass.StaticInnerClass();</span><br></pre></td></tr></table></figure></li><li><p>静态导包</p><p>在使用<strong>静态变量和方法</strong>时不用再指明 ClassName，从而简化代码，但可读性大大降低。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.xxx.ClassName.*</span><br></pre></td></tr></table></figure></li><li><p>初始化顺序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String staticField = <span class="string">&quot;静态变量&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;静态语句块&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String field = <span class="string">&quot;实例变量&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;普通语句块&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InitialOrderTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;构造函数&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>存在继承的情况下，初始化顺序为：先静态（先父类，再子类），再实例（先父类，再子类），先变量，普通语句块，再构造函数</p><ul><li>父类（静态变量、静态语句块）</li><li>子类（静态变量、静态语句块）</li><li>父类（实例变量、普通语句块）</li><li>父类（构造函数）</li><li>子类（实例变量、普通语句块）</li><li>子类（构造函数）</li></ul></li></ol><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>this表示当前类的实例，可以做以下几件事：</p><ol><li><p><code>this</code>关键字可用来引用当前类的实例变量。</p></li><li><p><code>this</code>关键字可用于调用当前类方法(隐式)。</p></li><li><p><code>this()</code>可以用来调用当前类的构造函数。</p></li><li><p><code>this</code>关键字可作为调用方法中的参数传递。</p></li><li><p><code>this</code>关键字可作为参数在构造函数调用中传递。</p></li><li><p><code>this</code>关键字可用于从方法返回当前类的实例。</p></li></ol><p>其实只要记住this就是当前类的实例对象就行，想咋操作就咋操作</p><p>参考：</p><ol><li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.yiibai.com/java/this-keyword.html">https://www.yiibai.com/java/this-keyword.html</a></li><li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://docs.oracle.com/javase/tutorial/java/javaOO/thiskey.html">https://docs.oracle.com/javase/tutorial/java/javaOO/thiskey.html</a></li></ol><h2 id="Object通用方法"><a href="#Object通用方法" class="headerlink" title="Object通用方法"></a>Object通用方法</h2><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; <span class="title">getClass</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span></span><br></pre></td></tr></table></figure><h3 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h3><ol><li><p>等价关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">x.equals(x); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">x.equals(y) == y.equals(x); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (x.equals(y) &amp;&amp; y.equals(z))</span><br><span class="line">    x.equals(z); <span class="comment">// true;</span></span><br><span class="line"></span><br><span class="line">x.equals(y) == x.equals(y); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">x.equals(<span class="keyword">null</span>); <span class="comment">// false;</span></span><br></pre></td></tr></table></figure></li><li><p>等价和相等（equals和==）</p><ul><li>对于基本类型：== 判断两个值是否相等，基本类型没有equals方法</li><li>对于引用类型：== 判断两个值是否引用自同一个对象，equals判断对象是否等价</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer x = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">Integer y = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">System.out.println(x.equals(y)); <span class="comment">// true</span></span><br><span class="line">System.out.println(x == y);      <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li><li><p>实现equals方法的一般逻辑</p><ul><li><strong>检查是否是同一个对象的引用</strong>，如果是直接返回true</li><li><strong>检查是否是同一个类型</strong>，如果不是直接返回false</li><li>将object对象进行转型（上一步已经检查过是否是同一个类型了，所以这里直接转型没问题）</li><li>判断每个关键域是否相等</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer b;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Example)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Example example = (Example) o;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(a, example.a) &amp;&amp; Objects.equals(b, example.b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关于Objects.equals(a, b)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object a, Object b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a == b) || (a != <span class="keyword">null</span> &amp;&amp; a.equals(b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h3><p>hashCode() 返回哈希值，而 equals() 是用来判断两个对象是否等价。<strong>等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价</strong>，这是因为<strong>计算哈希值具有随机性</strong>，<strong>两个值不同的对象可能计算出相同的哈希值</strong>。</p><p>在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象哈希值也相等。</p><p>HashSet 和 HashMap 等集合类使用了 hashCode() 方法来计算对象应该存储的位置，<strong>因此要将对象添加到这些集合类中，需要让对应的类实现 hashCode() 方法。</strong></p><p>重写hashCode方法可以用<code>Objects.hash()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// a b 是类的私有属性</span></span><br><span class="line">    <span class="keyword">return</span> Objects.hash(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以：</p><blockquote><p>理想的哈希函数应当具有均匀性，即不相等的对象应当均匀分布到所有可能的哈希值上。这就要求了哈希函数要把所有域的值都考虑进来。可以将每个域都当成 R 进制的某一位，然后组成一个 R 进制的整数。</p><p>R 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与 2 相乘相当于向左移一位，最左边的位丢失。并且一个数与 31 相乘可以转换成移位和减法：<code>31*x == (x&lt;&lt;5)-x</code>，编译器会自动进行这个优化。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">17</span>;</span><br><span class="line">    result = <span class="number">31</span> * result + x;</span><br><span class="line">    result = <span class="number">31</span> * result + y;</span><br><span class="line">    result = <span class="number">31</span> * result + z;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h3><p>默认返回 ToStringExample@4554617c 这种形式，其中 @ 后面的数值为<strong>散列码的无符号十六进制</strong>表示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Example example = <span class="keyword">new</span> Example(<span class="string">&quot;1&quot;</span>, <span class="number">1</span>);</span><br><span class="line">System.out.println(example.hashCode());	<span class="comment">// 2481</span></span><br><span class="line">System.out.println(example.toString());	<span class="comment">// com.hc.basics.Example@9b1</span></span><br></pre></td></tr></table></figure><p>9b1就是2481的16进制：<code>9*16^2 + 11 * 16 + 1 = 2481</code></p><h3 id="clone"><a href="#clone" class="headerlink" title="clone()"></a>clone()</h3><p><code>clone()</code>是Object类下的protected方法，这个类不显示的去重写<code>clone()</code>方法，其他类就不能直接调用</p><p>方法的作用就是复制一个对象，可以参考1.8API文档：</p><a href="/articles/40d12ba0/B18E4F2bfbimage-20220223171325738.png" class="gallery-item"><img src="/articles/40d12ba0/B18E4F2bfbimage-20220223171325738.png" title="image-20220223171325738"></a><p><code>clone()</code>方法可以保证：</p><ul><li>x.clone() != x：代表是正儿八经复制的个对象，在堆中有这个实例的一片地方</li><li>x.clone().getClass() == x.getClass()：保证类型相同</li><li>x.clone().equals(x)：保证复制后的对象的（字段）内容和之前的相同</li></ul><p>并且下面也说了：**<code>clone()</code>方法是浅拷贝，不是深拷贝**</p><p><strong>注意：重写了<code>clone()</code>方法后，如果这个方法不实现<code>Cloneable</code>接口，就会抛出<code>CloneNotSupportedException</code>异常，这个接口的作用就是打个标记，证明我这个类可以克隆，可以理解为一个约定</strong></p><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><p>浅拷贝就是只复制对象，但是对象的属性，是直接通过<code>=</code>号赋值，也就是对象是新建的，但是里面的属性都是复制的引用</p><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String subject;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 班长 */</span></span><br><span class="line">    <span class="keyword">private</span> Student classPresident;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Teacher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Teacher</span><span class="params">(String name, String subject, Student classPresident)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">        <span class="keyword">this</span>.classPresident = classPresident;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSubject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSubject</span><span class="params">(String subject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">getClassPresident</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> classPresident;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setClassPresident</span><span class="params">(Student classPresident)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.classPresident = classPresident;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Teacher <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Teacher) <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Teacher teacher = <span class="keyword">new</span> Teacher(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;math&quot;</span>, <span class="keyword">new</span> Student(<span class="string">&quot;b&quot;</span>));</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Teacher clone = teacher.clone();</span><br><span class="line">        System.out.println(teacher == clone);</span><br><span class="line">        System.out.println(teacher.getName() == clone.getName());</span><br><span class="line">        System.out.println(teacher.getSubject() == clone.getSubject());</span><br><span class="line">        System.out.println(teacher.getClassPresident() == clone.getClassPresident());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看看这俩student一样不：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure><p>可以看到，clone的对象确确实实是新建的，而克隆的对象的字段，确实是复制的引用，因为都是指向了同一个对象。</p><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><p>深拷贝就是完全把字段的属性也拷贝过来，而不是直接复制引用，重写<code>clone()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Teacher <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">    Teacher teacher = (Teacher) <span class="keyword">super</span>.clone();</span><br><span class="line">    teacher.name = <span class="keyword">new</span> String(<span class="keyword">this</span>.name);</span><br><span class="line">    teacher.subject = <span class="keyword">new</span> String(<span class="keyword">this</span>.subject);</span><br><span class="line">    teacher.classPresident = <span class="keyword">new</span> Student(<span class="keyword">this</span>.classPresident.getName());</span><br><span class="line">    <span class="keyword">return</span> teacher;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次运行main方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure><p>这也不是完全的深拷贝，因为classPresident的name也是引用过来的，所以要在一个复杂的对象里实现真正的深拷贝是非常困难的</p><p><strong>注意：String是不可变，我们再new一下意义不大，但是classPresident是可变的，如果不new就是公用一个对象，对象内容可能被克隆出来的副本改变了，影响到了原有的teacher</strong></p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>我们一般<strong>不用clone()方法来拷贝一个对象</strong>，既复杂（发生在子类的克隆需要链式调用父类的克隆）又有风险，还会抛出异常，还得类型转换，所以可以使用一个拷贝构造函数或者拷贝工厂来实现：</p><p>拷贝构造函数（在Teacher类中添加如下构造函数）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Teacher</span><span class="params">(Teacher original)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="keyword">new</span> String(original.name);</span><br><span class="line">    <span class="keyword">this</span>.subject = <span class="keyword">new</span> String(original.subject);</span><br><span class="line">    <span class="keyword">this</span>.classPresident = <span class="keyword">new</span> Student(original.classPresident.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Teacher teacher = <span class="keyword">new</span> Teacher(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;math&quot;</span>, <span class="keyword">new</span> Student(<span class="string">&quot;b&quot;</span>));</span><br><span class="line">Teacher clone = <span class="keyword">new</span> Teacher(teacher);</span><br><span class="line">System.out.println(teacher == clone);</span><br><span class="line">System.out.println(teacher.getName() == clone.getName());</span><br><span class="line">System.out.println(teacher.getSubject() == clone.getSubject());</span><br><span class="line">System.out.println(teacher.getClassPresident() == clone.getClassPresident());</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure><p>可以看出来拷贝构造函数确实很方便，不用抓异常，不用类型转换啥的</p><p>拷贝工厂（在Teacher类中添加如下静态方法）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Teacher <span class="title">newInstance</span><span class="params">(Teacher original)</span> </span>&#123;</span><br><span class="line">    Teacher teacher = <span class="keyword">new</span> Teacher();</span><br><span class="line">    teacher.name = <span class="keyword">new</span> String(original.name);</span><br><span class="line">    teacher.subject = <span class="keyword">new</span> String(original.subject);</span><br><span class="line">    teacher.classPresident = <span class="keyword">new</span> Student(original.classPresident.getName());</span><br><span class="line">    <span class="keyword">return</span> teacher;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Teacher teacher = <span class="keyword">new</span> Teacher(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;math&quot;</span>, <span class="keyword">new</span> Student(<span class="string">&quot;b&quot;</span>));</span><br><span class="line">Teacher clone = Teacher.newInstance(teacher);</span><br><span class="line">System.out.println(teacher == clone);</span><br><span class="line">System.out.println(teacher.getName() == clone.getName());</span><br><span class="line">System.out.println(teacher.getSubject() == clone.getSubject());</span><br><span class="line">System.out.println(teacher.getClassPresident() == clone.getClassPresident());</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>以下是一些缺点，因为许多开发人员不使用Object.clone（）</p><ol><li>使用Object.clone（）方法要求我们在代码中添加大量语法，如实现Cloneable接口，定义clone（）方法和处理CloneNotSupportedException，最后调用Object.clone（）并将其转换为对象。</li><li>Cloneable接口缺少clone（）方法，实际上Cloneable是一个标记接口，并且没有任何方法，我们仍然需要实现它只是告诉JVM我们可以对我们的对象执行clone（）。</li><li>Object.clone（）受到保护，因此我们必须提供自己的clone（）并从中间接调用Object.clone（）。</li><li>我们对对象构造没有任何控制，因为Object.clone（）不会调用任何构造函数。</li><li>如果我们在子类中编写克隆方法，例如 然后，所有人的超类应该在其中定义clone（）方法，或者从另一个父类继承它，否则super.clone（）链将失败。</li><li>Object.clone（）仅支持浅拷贝，因此我们新克隆对象的引用字段仍将保存原始对象的哪些字段所持有的对象。 为了克服这个问题，我们需要在我们的类所持有的每个类中实现clone（），然后在我们的clone（）方法中单独调用它们，如下例所示。</li><li>我们无法操作Object.clone（）中的final字段，因为最终字段只能通过构造函数进行更改。 在我们的例子中，如果我们希望每个Person对象都是id唯一的，那么如果我们使用Object.clone（），我们将获得重复的对象，因为Object.clone（）不会调用构造函数，并且最终的最终id字段不能被修改 来自Person.clone（）。</li></ol><p>复制构造函数优于Object.clone（），因为它们</p><ol><li>不要强迫我们实现任何接口或抛出任何异常，但如果需要，我们肯定可以这样做。</li><li>不要求任何演员阵容。</li><li>不要求我们依赖于未知的对象创建机制。</li><li>不要求父类遵守任何合同或实施任何内容。</li><li>允许我们修改最终字段。</li><li>允许我们完全控制对象创建，我们可以在其中编写初始化逻辑。</li></ol><p>参考：</p><ol><li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.itranslater.com/qa/details/2130931082093659136">https://www.itranslater.com/qa/details/2130931082093659136</a></li><li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://xiaoyue26.github.io/2017/03/03/%E6%8B%B7%E8%B4%9D%E5%B7%A5%E5%8E%82/">https://xiaoyue26.github.io/2017/03/03/%E6%8B%B7%E8%B4%9D%E5%B7%A5%E5%8E%82/</a></li><li><a target="_blank" rel="noopener external nofollow noreferrer" href="http://www.cyc2018.xyz/Java/Java%20%E5%9F%BA%E7%A1%80.html#clone">http://www.cyc2018.xyz/Java/Java%20%E5%9F%BA%E7%A1%80.html#clone</a></li><li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://docs.oracle.com/javase/8/docs/api/">https://docs.oracle.com/javase/8/docs/api/</a></li><li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.jianshu.com/p/41602eeb0ad5">https://www.jianshu.com/p/41602eeb0ad5</a></li></ol><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h3><ul><li>默认什么也不加（类、接口、方法、变量）：同一包内可见，外边包无法引入</li><li>private（变量、方法）：同一类内可见，<strong>可以修饰内部类，不能修饰外部类</strong></li><li>public（类、接口、方法、变量）：所有类可见</li><li>protected（变量、方法）：同一包内的类可见，子类也可见；<strong>可以修饰内部类，不能修饰外部类</strong></li></ul><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li><strong>子类拥有父类非 private 的属性、方法</strong></li><li><strong>子类可以拥有自己的属性和方法，即子类可以对父类进行扩展</strong></li><li><strong>子类可以用自己的方式实现父类的方法（重写）</strong></li><li><strong>Java 的继承是单继承，但是可以多重继承</strong>，单继承就是一个子类只能继承一个父类，多重继承就是，例如 B 类继承 A 类，C 类继承 B 类，所以按照关系就是 B 类是 C 类的父类，A 类是 B 类的父类，这是 Java 继承区别于 C++ 继承的一个特性</li><li><strong>提高了类之间的耦合性</strong>（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）</li></ul><h3 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h3><ol><li><p>抽象类</p><p>抽象类和抽象方法都用<code>abstract</code>关键字进行声明，如果一个类中包含抽象方法，那么这个类必须声明为抽象类。</p><p>抽象类和普通类最大的区别就是，<strong>抽象类不能被实例化，只能被继承。</strong></p></li><li><p>接口</p><p>接口是抽象类的延伸，在Java8之前，可以看做是个完全抽象的类，也就是说不能有任何方法的实现。</p><p><strong>从java8开始，接口可以拥有默认方法的实现</strong>，因为不支持默认方法的接口维护成本太高了，加一个方法，所有的实现类都需要实现。</p><p><strong>接口的成员（字段+方法）默认都是public的</strong>，并且不允许定义为private或protected的。</p><p><strong>从java9开始，允许将方法定义为private</strong>，这样就能定义某些复用的代码，并且还不会将方法暴露出去。</p><p>接口字段默认是static final的。</p></li><li><p>对比</p><ul><li>从设计层面上来看，抽象类提供了一种IS-A的关系，需要满足里氏替换原则，子类必须能替换所有父类对象。而接口更是一种LIKE-A的关系，提供方法的实现契约，不要求接口和接口实现的类有IS-A的关系。</li><li>从使用上来看，一个类可以实现多个接口，但不能继承多个抽象类</li><li>接口的字段必须是static和final的，而抽象类无限制</li><li>接口成员只能是public，抽象类的成员可以有多种访问权限</li></ul></li><li><p>使用选择</p><p>使用接口：</p><ul><li>需要让不相关的类都实现一个方法，例如不相关的类都实现Comparable的compareTo() 方法</li><li>需要使用多继承</li></ul><p>使用抽象类：</p><ul><li>需要在几个类中共享代码</li><li>需要能控制成员的访问权限</li><li>需要继承非静态和非常量字段</li></ul><p>很多情况下接口优于抽象类，没有抽象类的层次要求，可以灵活的为一个类添加行为</p></li></ol><h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><p>两种用途</p><ul><li>访问父类的构造函数：可以使用<code>super()</code>来访问父类构造函数，从而委托父类完成一些初始化的工作。应该注意到，子类一定会调用父类的构造函数来完成初始化工作，一般是调用父类的默认构造函数，但是也可以使用<code>super()</code>来有选择的调用其他的构造函数</li><li>访问父类的成员：如果子类重写了父类的某个方法，可以通过使用 super 关键字来引用父类的方法实现</li></ul><h3 id="重写和重载"><a href="#重写和重载" class="headerlink" title="重写和重载"></a>重写和重载</h3><ol><li><p>重写（Override）</p><p>存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法</p><p>为了满足里氏替换原则，重写有以下三个限制：</p><ul><li>子类方法的访问权限必须大于等于父类</li><li>子类的返回值类型必须是父类的方法返回类型或子类型</li><li>子类抛出的异常范围必须是父类抛出的异常类型或子类型</li></ul><p>使用@Override注解，可以让编译器帮忙检查是否满足以上三个条件</p><p><strong>注意：</strong>调用方法的时候，先从本类找有没有这个方法，再去父类找，如果都没有，那就要对参数进行转型，转成父类之后看看是否有对应的方法，总的来说方法调用优先级为：</p><ul><li>this.func(this)</li><li>super.func(this)</li><li>this.func(super)</li><li>super.func(super)</li></ul></li><li><p>重载（Overload）</p><p>存在于同一个类中，指一个方法与已经存在的方法名称相同，但是参数的个数，类型，顺序至少有一个不同</p><p>返回值不同，但其他相同，这不叫重载</p></li></ol><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>反射是Java的特性之一，允许程序在运行时获取自身的信息，并操作类或对象的的内部属性。</p><p>官方解释：</p><blockquote><p>Reflection is a feature in the Java programming language. It allows an executing Java program to examine or “introspect” upon itself, and manipulate internal properties of the program. For example, it’s possible for a Java class to obtain the names of all its members and display them.</p><p>One tangible use of reflection is in JavaBeans, where software components can be manipulated visually via a builder tool. The tool uses reflection to obtain the properties of Java components (classes) as they are dynamically loaded.</p></blockquote><p>翻译：</p><blockquote><p>反射是 Java 编程语言中的一个特性。它允许正在执行的 Java 程序检查或“自省”自身，并操纵程序的内部属性。例如，Java 类可以获取其所有成员的名称并显示它们。</p><p>反射的一种实际用途是在 JavaBeans 中，其中软件组件可以通过构建器工具进行可视化操作。该工具使用反射来获取动态加载的 Java 组件（类）的属性。</p></blockquote><p>反射的核心是JVM在运行时才动态加载类或调用方法/访问属性，不需要事先在编译期就确定运行对象是谁。</p><p>反射主要提供以下功能：</p><ul><li>运行时判断任意一个对象所属的类</li><li>运行时构造任意一个类的对象</li><li>运行时获取任意一个类所具有的的成员变量和方法（甚至可以获取私有方法）</li><li>运行时任意调用一个对象的方法</li></ul><p><strong>是运行时，而不是编译时</strong></p><p>其实学习反射主要是了解反射相关的APi就行了</p><h3 id="获取Class对象"><a href="#获取Class对象" class="headerlink" title="获取Class对象"></a>获取Class对象</h3><ol><li><p><strong>使用Class.forName(“className”)加载类</strong>，比如加载jdbc的数据库驱动，加载的时候会执行类中的静态代码块中的内容，从而把数据库驱动注册到DriverManager中，来连接数据库</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>对于对象，可以使用Object类的，getClass()方法</strong></p><a href="/articles/40d12ba0/eDBFbd0ECAimage-20220227173047677.png" class="gallery-item"><img src="/articles/40d12ba0/eDBFbd0ECAimage-20220227173047677.png" title="image-20220227173047677"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Example example = <span class="keyword">new</span> Example();</span><br><span class="line">Class&lt;? extends Example&gt; aClass = example.getClass();</span><br></pre></td></tr></table></figure></li><li><p><strong>对于类，可以直接<code>.class</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Integer&gt; intClass = <span class="keyword">int</span>.class;</span><br><span class="line">Class&lt;? extends Integer&gt; integerClass = Integer.class;</span><br></pre></td></tr></table></figure></li></ol><h4 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Example a = <span class="keyword">new</span> Example();</span><br><span class="line"><span class="comment">// 通过调用对象的getClass来获取</span></span><br><span class="line">Class&lt;? extends Example&gt; aClass = a.getClass();</span><br><span class="line"><span class="comment">// 直接类名.class</span></span><br><span class="line">Class&lt;Example&gt; clazz = Example.class;</span><br><span class="line"><span class="comment">// 传全限定类名</span></span><br><span class="line">Class&lt;?&gt; aClass1 = Class.forName(<span class="string">&quot;com.hc.basics.Example&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="判断某个对象是否是某个类的实例"><a href="#判断某个对象是否是某个类的实例" class="headerlink" title="判断某个对象是否是某个类的实例"></a>判断某个对象是否是某个类的实例</h3><p>使用Class类的isInstance(Object o)方法，方法签名如下</p><a href="/articles/40d12ba0/9ec4c2DD1Fimage-20220227174558415.png" class="gallery-item"><img src="/articles/40d12ba0/9ec4c2DD1Fimage-20220227174558415.png" title="image-20220227174558415"></a><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Example a = <span class="keyword">new</span> Example();</span><br><span class="line">Example b = <span class="keyword">new</span> Example();</span><br><span class="line">Class&lt;? extends Example&gt; aClass = a.getClass();</span><br><span class="line"><span class="comment">// 判断b对象是否是Example类的实例</span></span><br><span class="line">System.out.println(aClass.isInstance(b));</span><br></pre></td></tr></table></figure><h3 id="使用Class对象创建实例"><a href="#使用Class对象创建实例" class="headerlink" title="使用Class对象创建实例"></a>使用Class对象创建实例</h3><p>创建实例肯定是需要一个构造方法的，分别是无参和带参的构造方法：</p><ul><li>无参构造：直接使用<code>class实例的newInstance()</code>方法</li><li>带参构造：需要先获取构造器<code>clazz.getConstructor(Integer.class, String.class)</code>，是靠传入参数的顺序来判断使用哪个构造函数的，然后用构造器<code>newInstance()</code>创建实例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Example的Class对象创建Example实例</span></span><br><span class="line">Class&lt;Example&gt; clazz = Example.class;</span><br><span class="line">Example example = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    example = clazz.newInstance();</span><br><span class="line">    System.out.println(<span class="string">&quot;无参构造：&quot;</span> + example);</span><br><span class="line">    Constructor&lt;Example&gt; constructor = clazz.getConstructor(Integer.class, String.class);</span><br><span class="line">    example = constructor.newInstance(<span class="number">1</span>, <span class="string">&quot;jack&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;带参构造：&quot;</span> + example);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException | NoSuchMethodException | InvocationTargetException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取某个类的所有方法"><a href="#获取某个类的所有方法" class="headerlink" title="获取某个类的所有方法"></a>获取某个类的所有方法</h3><ul><li><p><code>getDeclaredMethods</code> 方法返回类或接口声明的所有方法，<strong>包括公共、保护、默认（包）访问和私有方法</strong>，但<strong>不包括继承的方法</strong>。</p><p>可以理解为只要是当前类里面写的方法，全部都拿出来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Method[] getDeclaredMethods() <span class="keyword">throws</span> SecurityException</span><br></pre></td></tr></table></figure></li><li><p><code>getMethods</code> 方法返回某个类的<strong>所有公用（public）方法，包括其继承类的公用方法</strong>。</p><p>也就是会把<code>Object</code>类的所有方法也都搞出来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Method[] getMethods() <span class="keyword">throws</span> SecurityException</span><br></pre></td></tr></table></figure></li><li><p><code>getMethod</code> 方法<strong>返回一个特定的方法</strong>，其中<strong>第一个参数为方法名称</strong>，后面的<strong>参数为方法的参数对应Class的对象。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Method <span class="title">getMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span></span></span><br></pre></td></tr></table></figure></li></ul><h3 id="获取类字段信息"><a href="#获取类字段信息" class="headerlink" title="获取类字段信息"></a>获取类字段信息</h3><ul><li><p><code>getFiled</code>：访问公有的成员变量</p></li><li><p><code>getDeclaredField</code>：所有已声明的成员变量，但不能得到其父类的成员变量</p></li><li><p><code>getFileds</code> 和 <code>getDeclaredFields</code> 方法用法同上（参照 Method）</p></li></ul><h3 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h3><p>使用Method类中的invoke方法进行实际调用，需要传入实例和方法参数，返回是方法执行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Example的Class对象创建Example实例</span></span><br><span class="line">Class&lt;Example&gt; clazz = Example.class;</span><br><span class="line">Example example = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 先创建个对象</span></span><br><span class="line">    example = clazz.newInstance();</span><br><span class="line">    <span class="comment">// clazz.getMethod 获取指定方法</span></span><br><span class="line">    Method introduceMethod = clazz.getMethod(<span class="string">&quot;introduce&quot;</span>, Integer.class, String.class);</span><br><span class="line">    <span class="comment">// 调用</span></span><br><span class="line">    Object result = introduceMethod.invoke(example, <span class="number">1</span>, <span class="string">&quot;jack&quot;</span>);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException | NoSuchMethodException | InvocationTargetException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ul><li><strong>可扩展性</strong> ：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类。</li><li><strong>类浏览器和可视化开发环境</strong> ：一个类浏览器需要可以枚举类的成员。可视化开发环境（如 IDE）可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码。</li><li><strong>调试器和测试工具</strong> ： 调试器需要能够检查一个类里的私有成员。测试工具可以利用反射来自动地调用类里定义的可被发现的 API 定义，以确保一组测试中有较高的代码覆盖率。</li></ul><p>缺点：</p><ul><li><strong>性能开销</strong> ：反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。</li><li><strong>安全限制</strong> ：使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 Applet，那么这就是个问题了。</li><li><strong>内部暴露</strong> ：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。</li></ul><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>Throwable 可以用来表示任何可以作为异常抛出的类，分为两种： <strong>Error</strong> 和 <strong>Exception</strong>。其中 Error 用来表示 JVM 无法处理的错误，Exception 分为两种：</p><ul><li><strong>受检异常</strong> ：需要用 try…catch… 语句捕获并进行处理，并且可以从异常中恢复；在正确的程序运行过程中，很容易出现的、情理可容的异常状况，在一定程度上这种异常的发生是可以预测的，并且一旦发生该种异常，就必须采取某种方式进行处理。</li><li><strong>非受检异常</strong> ：是程序运行时错误，例如除 0 会引发 Arithmetic Exception，此时程序崩溃并且无法恢复；包括<code>RuntimeException</code>及其子类和<code>Error</code></li></ul><blockquote><p><code>不受检查异常</code>为编译器不要求强制处理的异常，<code>检查异常</code>则是编译器要求必须处置的异常。</p></blockquote><a href="/articles/40d12ba0/cd4D902bf3image-20220302150727651.png" class="gallery-item"><img src="/articles/40d12ba0/cd4D902bf3image-20220302150727651.png" title="image-20220302150727651"></a><h3 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h3><p>多个try块嵌套，优先在距离最近的catch块处理，如果当前catch不能能处理，则到上一级try的catch块处理</p><h3 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h3><p>finally会在return前执行，不要再finally中return！</p><p>如果在finally中修改方法中的变量，对于基本类型，无法修改，对于引用类型，可以修改引用类型的内容</p><p>finally中经常干的事情就是释放资源</p><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">testException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        i = <span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(testException());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>引用类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> People <span class="title">testException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    People people = <span class="keyword">new</span> People();</span><br><span class="line">    people.setName(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        people.setAge(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">return</span> people;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        people.setName(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">        people.setAge(<span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> people;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(testException());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output</span></span><br><span class="line">People&#123;name=<span class="string">&#x27;bb&#x27;</span>, age=<span class="number">6</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><blockquote><p><strong>泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。</strong></p><p><strong>泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）</strong>。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。</p></blockquote><p>注意：泛型只是在编译时限制的，在运行时会擦除，仅用做编译时限制开发人员别放错类型了</p><p>下面这个是泛型类，泛型类与泛型接口都差不多，都是类名 + <code>&lt;T&gt;</code>，尖括号里面的字母写啥都行，只不过为了让人看懂，衍生出了，T、K、V、E、N、?</p><ul><li><strong>E</strong> - Element (在集合中使用，因为集合中存放的是元素)</li><li><strong>T</strong> - Type（Java 类）</li><li><strong>K</strong> - Key（键）</li><li><strong>V</strong> - Value（值）</li><li><strong>N</strong> - Number（数值类型）</li><li><strong>？</strong> - 表示不确定的 java 类型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T t;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.t = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 泛型方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;K,V&gt; <span class="function">T <span class="title">test</span><span class="params">(T t, K k, V v)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;K: &quot;</span> + k + <span class="string">&quot; V: &quot;</span> + v + <span class="string">&quot; T: &quot;</span> + t);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>上面的get和set是泛型方法吗？不是</p><p>test才是泛型方法</p><p><strong>泛型类，是在实例化类的时候指明泛型的具体类型；泛型方法，是在调用方法的时候指明泛型的具体类型</strong> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;K,V&gt; <span class="function">T <span class="title">test</span><span class="params">(T t, K k, V v)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;K: &quot;</span> + k + <span class="string">&quot; V: &quot;</span> + v + <span class="string">&quot; T: &quot;</span> + t);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>上面的public 和 T 中间的 <code>&lt;K,V&gt;</code>可以理解为声明此方法是个泛型方法，并且会用到K、V这俩类型</li><li>只有这样声明了，才是泛型方法，没用这样声明的都不是，<strong>一般这个声明后面紧跟返回参数类型</strong></li><li>这个T为啥不声明呢？是因为这个T是泛型类声明的泛型，所以这里可以直接用，不用再次声明</li></ul><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Box&lt;Integer&gt; box = <span class="keyword">new</span> Box&lt;&gt;();</span><br><span class="line">    box.set(<span class="number">666</span>);</span><br><span class="line">    System.out.println(box.get());</span><br><span class="line">    Integer haha = box.test(<span class="number">111</span>, <span class="string">&quot;haha&quot;</span>, <span class="number">333</span>);</span><br><span class="line">    System.out.println(haha);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="number">666</span></span><br><span class="line">K: haha V: <span class="number">333</span> T: <span class="number">111</span></span><br><span class="line"><span class="number">111</span></span><br></pre></td></tr></table></figure><h3 id="泛型方法与可变参数"><a href="#泛型方法与可变参数" class="headerlink" title="泛型方法与可变参数"></a>泛型方法与可变参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">printMsg</span><span class="params">(T... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (T arg : args) &#123;</span><br><span class="line">        System.out.println(arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    printMsg(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&quot;haha&quot;</span>, <span class="string">&quot;hehe&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tips:</p><blockquote><p>无论何时，如果你能做到，你就该尽量使用泛型方法。也就是说，如果使用泛型方法将整个类泛型化，那么就应该使用泛型方法。另外对于一个static的方法而已，无法访问泛型类型的参数。所以如果static方法要使用泛型能力，就必须使其成为泛型方法。</p></blockquote><h3 id="泛型的上下边界"><a href="#泛型的上下边界" class="headerlink" title="泛型的上下边界"></a>泛型的上下边界</h3><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote><p>在Java泛型定义时:</p><p>用<t>等大写字母标识泛型类型，用于表示未知类型。<br>用&lt;T extends ClassA &amp; InterfaceB …&gt;等标识有界泛型类型，用于表示有边界的未知类型。<br>在Java泛型实例化时:</t></p><p>用&lt;?&gt;标识通配符，用于表示实例化时的未知类型。<br>用&lt;? extends 父类型&gt;标识上边界通配符，用于表示实例化时可以确定父类型的未知类型。<br>用&lt;? super 子类型&gt;标识下边界通配符，用于表示实例化时可以确定子类型的未知类型。</p></blockquote><h4 id="上边界"><a href="#上边界" class="headerlink" title="上边界"></a>上边界</h4><p>定义：<code>&lt;T extends Number&gt;</code>表示必须是Number的子类才行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Number&gt; <span class="function"><span class="keyword">void</span> <span class="title">printMsg</span><span class="params">(T... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (T arg : args) &#123;</span><br><span class="line">        System.out.println(arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不是，编译会报错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    printMsg(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&quot;haha&quot;</span>, <span class="string">&quot;hehe&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译报错</span></span><br><span class="line">java: 无法将类 com.hc.demo.TestBox中的方法 printMsg应用到给定类型;</span><br><span class="line">  需要: T[]</span><br><span class="line">  找到: <span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">int</span>,java.lang.String,java.lang.String</span><br><span class="line">  原因: 推断类型不符合上限</span><br><span class="line">    推断: java.lang.Object&amp;java.io.Serializable&amp;java.lang.Comparable&lt;? extends java.lang.Object&amp;java.io.Serializable&amp;java.lang.Comparable&lt;?&gt;&gt;</span><br><span class="line">    上限: java.lang.Number</span><br></pre></td></tr></table></figure><h4 id="下边界"><a href="#下边界" class="headerlink" title="下边界"></a>下边界</h4><p>注意：下边界定义时不能限制，只能实例化时限制</p><p>这个限定了只能放People的子类，放其他类如cat就不行，限定了下界</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Box&lt;? <span class="keyword">super</span> People&gt; box = <span class="keyword">new</span> Box&lt;&gt;();</span><br><span class="line">    box.set(<span class="keyword">new</span> People());</span><br><span class="line">    box.set(<span class="keyword">new</span> Student());</span><br><span class="line">    box.set(<span class="keyword">new</span> Cat());  <span class="comment">// error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output</span></span><br><span class="line">java: 不兼容的类型: com.hc.demo.Cat无法转换为capture#<span class="number">1</span>, 共 ? <span class="keyword">super</span> com.hc.demo.People</span><br></pre></td></tr></table></figure><h3 id="不得不说泛型数组"><a href="#不得不说泛型数组" class="headerlink" title="不得不说泛型数组"></a>不得不说泛型数组</h3><p>在Java中不允许创建确切类型的泛型数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt;[] lsa = <span class="keyword">new</span> List&lt;String&gt;[<span class="number">10</span>]; <span class="comment">// Not really allowed.    </span></span><br><span class="line">    Object o = lsa;</span><br><span class="line">    Object[] oa = (Object[]) o;</span><br><span class="line">    List&lt;Integer&gt; li = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    li.add(<span class="keyword">new</span> Integer(<span class="number">3</span>));</span><br><span class="line">    oa[<span class="number">1</span>] = li; <span class="comment">// Unsound, but passes run time store check    </span></span><br><span class="line">    String s = lsa[<span class="number">1</span>].get(<span class="number">0</span>); <span class="comment">// Run-time error: ClassCastException.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除非是采用通配符的方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt;[] lsa = <span class="keyword">new</span> List&lt;?&gt;[<span class="number">10</span>]; <span class="comment">// OK, array of unbounded wildcard type.    </span></span><br><span class="line">Object o = lsa;    </span><br><span class="line">Object[] oa = (Object[]) o;    </span><br><span class="line">List&lt;Integer&gt; li = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();    </span><br><span class="line">li.add(<span class="keyword">new</span> Integer(<span class="number">3</span>));    </span><br><span class="line">oa[<span class="number">1</span>] = li; <span class="comment">// Correct.    </span></span><br><span class="line">Integer i = (Integer) lsa[<span class="number">1</span>].get(<span class="number">0</span>); <span class="comment">// OK </span></span><br></pre></td></tr></table></figure><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><blockquote><p>Java注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。包含在 java.lang.annotation 包中。</p></blockquote><h3 id="可以做什么"><a href="#可以做什么" class="headerlink" title="可以做什么"></a>可以做什么</h3><ol><li>生成文档，这是最常见的，也是java 最早提供的注解。常用的有@param @return 等</li><li>跟踪代码依赖性，实现替代配置文件功能。如 @MapperScan(‘com.hc.demo’)</li><li>在编译时进行格式检查。如@override 放在方法前，如果你这个方法并不是覆盖了超类方法，则编译时就能检查出。</li></ol><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>注解本质是一个继承了Annotation 的特殊接口，其具体实现类是Java 运行时生成的动态代理类。而我们通过反射获取注解时，返回的是Java 运行时生成的动态代理对象$Proxy1。通过代理对象调用自定义注解（接口）的方法，会最终调用AnnotationInvocationHandler 的invoke 方法。该方法会从memberValues 这个Map 中索引出对应的值。而memberValues 的来源是Java 常量池。</p><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>java.lang.annotation 提供了四种元注解，专门注解其他的注解（在自定义注解的时候，需要使用到元注解）：<br>@Documented – 注解是否将包含在JavaDoc中<br>@Retention – 什么时候使用该注解<br>@Target – 注解用于什么地方<br>@Inherited – 是否允许子类继承该注解</p><ol><li><p>@Retention</p><ul><li>RetentionPolicy.SOURCE : 在编译阶段丢弃。这些注解在编译结束之后就不再有任何意义，所以它们不会写入字节码。@Override, @SuppressWarnings都属于这类注解。</li><li>RetentionPolicy.CLASS : 在类加载的时候丢弃。在字节码文件的处理中有用。注解默认使用这种方式</li><li>RetentionPolicy.RUNTIME : 始终不会丢弃，运行期也保留该注解，因此可以使用反射机制读取该注解的信息。我们自定义的注解通常使用这种方式。</li></ul></li><li><p>@Target</p><ul><li>ElementType.CONSTRUCTOR: 用于描述构造器</li><li>ElementType.FIELD: 成员变量、对象、属性（包括enum实例）</li><li>ElementType.LOCAL_VARIABLE: 用于描述局部变量</li><li>ElementType.METHOD: 用于描述方法</li><li>ElementType.PACKAGE: 用于描述包</li><li>ElementType.PARAMETER: 用于描述参数</li><li>ElementType.TYPE: 用于描述类、接口(包括注解类型) 或enum声明</li></ul></li><li><p>@Inherited – 定义该注释和子类的关系</p><p>@Inherited 元注解是一个标记注解，@Inherited 阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited 修饰的annotation 类型被用于一个class，则这个annotation 将被用于该class 的子类。</p></li></ol><h3 id="常见注解"><a href="#常见注解" class="headerlink" title="常见注解"></a>常见注解</h3><ul><li><p>Override</p><p>java.lang.Override 是一个标记类型注解，它被用作标注方法。它说明了被标注的方法重写了父类的方法，起到了断言的作用。如果我们使用了这种注解在一个没有覆盖父类方法的方法时，java 编译器将以一个编译错误来警示。就是编译的时候提醒下，编译完了就没这个注解了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Deprecated</p><p>打上这个注解，编译器就会提示某个方法过期了，不建议使用，但是还是可以使用的，不一定是方法，这个可以在任意元素上加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Deprecated &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>SuppressWarnings</p><p>会忽略警告，也是只存在编译期间，可以用在任意元素上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SuppressWarnings &#123;</span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="自定义注解的规则"><a href="#自定义注解的规则" class="headerlink" title="自定义注解的规则"></a>自定义注解的规则</h3><p>自定义注解类编写的一些规则:</p><ul><li>Annotation 型定义为@interface, 所有 的Annotation 会自动继承java.lang.Annotation这一接口,并且不能再去继承别的类或是接口.</li><li>参数成员只能用public 或默认(default) 这两个访问权修饰</li><li>参数成员只能用基本类型byte、short、char、int、long、float、double、boolean八种基本数据类型和String、Enum、Class、annotations等数据类型，以及这一些类型的数组.</li><li>要获取类方法和字段的注解信息，必须通过Java的反射技术来获取 Annotation 对象，因为你除此之外没有别的获取注解对象的方法</li><li>注解也可以没有定义成员，不过这样注解就没啥用了</li><li>自定义注解需要使用到元注解</li></ul><h3 id="自定义注解例子"><a href="#自定义注解例子" class="headerlink" title="自定义注解例子"></a>自定义注解例子</h3><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/hczs/weather-mail">https://github.com/hczs/weather-mail</a></p><p>自定义注解 + aop，实现自定义日志注解，在方法上加上@PrintLog注解，即可在控制台打印方法执行的日志，如方法执行时间，执行了哪个方法，方法执行完毕结束时间</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>var options;"undefined"!=typeof lightGallery&&(options={selector:".gallery-item"},lightGallery(document.getElementsByClassName(".article-gallery")[0],options))</script></div></article><div class="blog-post-comments"><div id="disqus_thread"><noscript>加载评论需要在浏览器启用 JavaScript 脚本支持。</noscript></div></div><div id="footer-post-container"><div id="footer-post"><div id="nav-footer" style="display:none"><ul><li><a href="/">首页</a></li><li><a href="/archives/">文章</a></li><li><a href="/categories/">分类</a></li><li><a href="/search/">搜索</a></li><li><a href="/about/">关于</a></li></ul></div><div id="toc-footer" style="display:none"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">Java基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.1.</span> <span class="toc-text">基本类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.2.</span> <span class="toc-text">包装类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%B1%A0"><span class="toc-number">1.1.3.</span> <span class="toc-text">缓存池</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String"><span class="toc-number">1.2.</span> <span class="toc-text">String</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.2.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E5%95%A5%E8%A6%81%E6%8A%8AString%E6%90%9E%E6%88%90%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%EF%BC%9F"><span class="toc-number">1.2.2.</span> <span class="toc-text">为啥要把String搞成不可变的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String%E3%80%81StringBuffer%E3%80%81StringBuilder"><span class="toc-number">1.2.3.</span> <span class="toc-text">String、StringBuffer、StringBuilder</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-number">1.2.4.</span> <span class="toc-text">字符串常量池</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97"><span class="toc-number">1.3.</span> <span class="toc-text">运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%EF%BC%9AJava%E4%B8%AD%E5%8F%AA%E6%9C%89%E5%80%BC%E4%BC%A0%E9%80%92%EF%BC%8C%E6%B2%A1%E6%9C%89%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%EF%BC%81"><span class="toc-number">1.3.1.</span> <span class="toc-text">参数传递：Java中只有值传递，没有引用传递！</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.3.2.</span> <span class="toc-text">隐式类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#switch"><span class="toc-number">1.3.3.</span> <span class="toc-text">switch</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97-TODO"><span class="toc-number">1.4.</span> <span class="toc-text">关键字 TODO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#final"><span class="toc-number">1.4.1.</span> <span class="toc-text">final</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#static"><span class="toc-number">1.4.2.</span> <span class="toc-text">static</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this"><span class="toc-number">1.4.3.</span> <span class="toc-text">this</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.</span> <span class="toc-text">Object通用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%A7%88"><span class="toc-number">1.5.1.</span> <span class="toc-text">概览</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#equals"><span class="toc-number">1.5.2.</span> <span class="toc-text">equals()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashCode"><span class="toc-number">1.5.3.</span> <span class="toc-text">hashCode()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#toString-NaN"><span class="toc-number">1.5.4.</span> <span class="toc-text">toString()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#clone"><span class="toc-number">1.5.5.</span> <span class="toc-text">clone()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.5.5.1.</span> <span class="toc-text">浅拷贝</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.5.5.2.</span> <span class="toc-text">深拷贝</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">1.5.5.3.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">1.5.5.4.</span> <span class="toc-text">缺点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">1.6.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">1.6.1.</span> <span class="toc-text">访问修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%80%A7"><span class="toc-number">1.6.2.</span> <span class="toc-text">特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.6.3.</span> <span class="toc-text">抽象类和接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#super"><span class="toc-number">1.6.4.</span> <span class="toc-text">super</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%86%99%E5%92%8C%E9%87%8D%E8%BD%BD"><span class="toc-number">1.6.5.</span> <span class="toc-text">重写和重载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">1.7.</span> <span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="toc-number">1.7.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96Class%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.7.2.</span> <span class="toc-text">获取Class对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%87%E6%80%BB"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">汇总</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%9F%90%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E6%98%AF%E6%9F%90%E4%B8%AA%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.7.3.</span> <span class="toc-text">判断某个对象是否是某个类的实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Class%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.7.4.</span> <span class="toc-text">使用Class对象创建实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%9F%90%E4%B8%AA%E7%B1%BB%E7%9A%84%E6%89%80%E6%9C%89%E6%96%B9%E6%B3%95"><span class="toc-number">1.7.5.</span> <span class="toc-text">获取某个类的所有方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%B1%BB%E5%AD%97%E6%AE%B5%E4%BF%A1%E6%81%AF"><span class="toc-number">1.7.6.</span> <span class="toc-text">获取类字段信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.7.7.</span> <span class="toc-text">调用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">1.7.8.</span> <span class="toc-text">优缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">1.8.</span> <span class="toc-text">异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-2"><span class="toc-number">1.8.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97"><span class="toc-number">1.8.2.</span> <span class="toc-text">嵌套</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#finally"><span class="toc-number">1.8.3.</span> <span class="toc-text">finally</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">1.9.</span> <span class="toc-text">泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-3"><span class="toc-number">1.9.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-number">1.9.2.</span> <span class="toc-text">泛型方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-1"><span class="toc-number">1.9.3.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95%E4%B8%8E%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-number">1.9.4.</span> <span class="toc-text">泛型方法与可变参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%B8%8A%E4%B8%8B%E8%BE%B9%E7%95%8C"><span class="toc-number">1.9.5.</span> <span class="toc-text">泛型的上下边界</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.9.5.1.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8A%E8%BE%B9%E7%95%8C"><span class="toc-number">1.9.5.2.</span> <span class="toc-text">上边界</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8B%E8%BE%B9%E7%95%8C"><span class="toc-number">1.9.5.3.</span> <span class="toc-text">下边界</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%BE%97%E4%B8%8D%E8%AF%B4%E6%B3%9B%E5%9E%8B%E6%95%B0%E7%BB%84"><span class="toc-number">1.9.6.</span> <span class="toc-text">不得不说泛型数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.10.</span> <span class="toc-text">注解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.10.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E4%BB%A5%E5%81%9A%E4%BB%80%E4%B9%88"><span class="toc-number">1.10.2.</span> <span class="toc-text">可以做什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">1.10.3.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.10.4.</span> <span class="toc-text">元注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.10.5.</span> <span class="toc-text">常见注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-number">1.10.6.</span> <span class="toc-text">自定义注解的规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E4%BE%8B%E5%AD%90"><span class="toc-number">1.10.7.</span> <span class="toc-text">自定义注解例子</span></a></li></ol></li></ol></li></ol></div><div id="share-footer" style="display:none"><ul><li><a class="icon" target="_blank" rel="noopener external nofollow noreferrer" href="http://www.facebook.com/sharer.php?u=https://www.powercheng.fun/articles/40d12ba0/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener external nofollow noreferrer" href="https://twitter.com/share?url=https://www.powercheng.fun/articles/40d12ba0/&text=Java基础总结篇"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener external nofollow noreferrer" href="http://www.linkedin.com/shareArticle?url=https://www.powercheng.fun/articles/40d12ba0/&title=Java基础总结篇"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener external nofollow noreferrer" href="https://pinterest.com/pin/create/bookmarklet/?url=https://www.powercheng.fun/articles/40d12ba0/&is_video=false&description=Java基础总结篇"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=Java基础总结篇&body=Check out this article: https://www.powercheng.fun/articles/40d12ba0/" rel="external nofollow noreferrer"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener external nofollow noreferrer" href="https://getpocket.com/save?url=https://www.powercheng.fun/articles/40d12ba0/&title=Java基础总结篇"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener external nofollow noreferrer" href="http://reddit.com/submit?url=https://www.powercheng.fun/articles/40d12ba0/&title=Java基础总结篇"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener external nofollow noreferrer" href="http://www.stumbleupon.com/submit?url=https://www.powercheng.fun/articles/40d12ba0/&title=Java基础总结篇"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener external nofollow noreferrer" href="http://digg.com/submit?url=https://www.powercheng.fun/articles/40d12ba0/&title=Java基础总结篇"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" href="http://www.tumblr.com/share/link?url=https://www.powercheng.fun/articles/40d12ba0/&name=Java基础总结篇&description=&lt;link rel=&#34;stylesheet&#34; type=&#34;text/css&#34; href=&#34;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&#34; /&gt;&lt;div class=&#34;.article-gallery&#34;&gt;&lt;p&gt;关于Java基础方面的总结，快四个月没写过Java了，回忆一下&lt;/p&gt;"><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener external nofollow noreferrer" href="https://news.ycombinator.com/submitlink?u=https://www.powercheng.fun/articles/40d12ba0/&t=Java基础总结篇"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li></ul></div><div id="actions-footer"><a id="menu" class="icon" href="#" onclick='return $("#nav-footer").toggle(),!1'><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> 菜单</a> <a id="toc" class="icon" href="#" onclick='return $("#toc-footer").toggle(),!1'><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> 目录</a> <a id="share" class="icon" href="#" onclick='return $("#share-footer").toggle(),!1'><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a> <a id="top" style="display:none" class="icon" href="#" onclick='$("html, body").animate({scrollTop:0},"fast")'><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a></div></div></div><footer id="footer"><div class="footer-left">Copyright &copy; 2021-2025 Caiden Hou</div><div class="footer-right"><nav><ul><li><a href="/">首页</a></li><li><a href="/archives/">文章</a></li><li><a href="/categories/">分类</a></li><li><a href="/search/">搜索</a></li><li><a href="/about/">关于</a></li></ul></nav></div></footer></div><link rel="preload" href="/lib/font-awesome/css/all.min.css" as="style" onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"></noscript><script src="/lib/jquery/jquery.min.js"></script><script src="/lib/clipboard/clipboard.min.js"></script><script type="text/javascript">$(function(){$(".highlight table").before('<span class="btn-copy tooltipped tooltipped-sw" aria-label="复制到粘贴板！"><i class="fa-regular fa-clone"></i></span>'),new ClipboardJS(".btn-copy",{text:function(e){return Array.from(e.nextElementSibling.querySelectorAll(".code")).reduce((e,t)=>e+t.innerText+"\n","")}}).on("success",function(e){e.trigger.setAttribute("aria-label","复制成功！"),e.clearSelection()})})</script><script src="/js/main.js"></script><script type="text/javascript">var disqus_shortname="caidens-blog";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}()</script></body></html>