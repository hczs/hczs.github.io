<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5"><meta name="description" content="关于lambda表达式、streamAPI、Optional和新的日期时间API的总结"><meta property="og:type" content="article"><meta property="og:title" content="JDK1.8新特性"><meta property="og:url" content="https://www.powercheng.fun/articles/d111bf74/index.html"><meta property="og:site_name" content="Caiden&#39;s Blog"><meta property="og:description" content="关于lambda表达式、streamAPI、Optional和新的日期时间API的总结"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.powercheng.fun/articles/d111bf74/8Ea31cd87bimage-20220304111057588.png"><meta property="og:image" content="https://www.powercheng.fun/articles/d111bf74/efD9F7a5BCimage-20220304110927875.png"><meta property="og:image" content="https://www.powercheng.fun/articles/d111bf74/F57C8a92eFimage-20220304111118157.png"><meta property="article:published_time" content="2022-03-04T03:12:54.000Z"><meta property="article:modified_time" content="2025-11-19T03:04:36.717Z"><meta property="article:author" content="Caiden Hou"><meta property="article:tag" content="Java"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://www.powercheng.fun/articles/d111bf74/8Ea31cd87bimage-20220304111057588.png"><link rel="shortcut icon" href="/images/favicon.ico"><link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="stylesheet" href="https://gw.alipayobjects.com/os/k/font/lxgwwenkaiscreenr.css"><title>JDK1.8新特性</title><link rel="stylesheet" href="/css/style.css"><link rel="alternate" href="/true" title="Caiden&#39;s Blog" type="application/atom+xml"><meta name="generator" content="Hexo 5.4.0"></head><body class="max-width mx-auto px3 ltr"><div id="header-post"><a id="menu-icon" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" aria-label="顶部" onclick='$("html, body").animate({scrollTop:0},"fast")' style="display:none"><i class="fa-solid fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">首页</a></li><li><a href="/archives/">文章</a></li><li><a href="/categories/">分类</a></li><li><a href="/search/">搜索</a></li><li><a href="/about/">关于</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" aria-label="上一篇" href="/articles/2c8b996c/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle()' onmouseout='$("#i-prev").toggle()'></i></a></li><li><a class="icon" aria-label="下一篇" href="/articles/3b4b1d9a/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle()' onmouseout='$("#i-next").toggle()'></i></a></li><li><a class="icon" aria-label="返回顶部" href="#" onclick='$("html, body").animate({scrollTop:0},"fast")'><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle()' onmouseout='$("#i-top").toggle()'></i></a></li><li><a class="icon" aria-label="分享文章" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle()' onmouseout='$("#i-share").toggle()' onclick='return $("#share").toggle(),!1'></i></a></li></ul><span id="i-prev" class="info" style="display:none">上一篇</span> <span id="i-next" class="info" style="display:none">下一篇</span> <span id="i-top" class="info" style="display:none">返回顶部</span> <span id="i-share" class="info" style="display:none">分享文章</span></span><br><div id="share" style="display:none"><ul><li><a class="icon" target="_blank" rel="noopener external nofollow noreferrer" href="http://www.facebook.com/sharer.php?u=https://www.powercheng.fun/articles/d111bf74/"><i class="fab fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener external nofollow noreferrer" href="https://twitter.com/share?url=https://www.powercheng.fun/articles/d111bf74/&text=JDK1.8新特性"><i class="fab fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener external nofollow noreferrer" href="http://www.linkedin.com/shareArticle?url=https://www.powercheng.fun/articles/d111bf74/&title=JDK1.8新特性"><i class="fab fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener external nofollow noreferrer" href="https://pinterest.com/pin/create/bookmarklet/?url=https://www.powercheng.fun/articles/d111bf74/&is_video=false&description=JDK1.8新特性"><i class="fab fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=JDK1.8新特性&body=Check out this article: https://www.powercheng.fun/articles/d111bf74/" rel="external nofollow noreferrer"><i class="fa-solid fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener external nofollow noreferrer" href="https://getpocket.com/save?url=https://www.powercheng.fun/articles/d111bf74/&title=JDK1.8新特性"><i class="fab fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener external nofollow noreferrer" href="http://reddit.com/submit?url=https://www.powercheng.fun/articles/d111bf74/&title=JDK1.8新特性"><i class="fab fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener external nofollow noreferrer" href="http://www.stumbleupon.com/submit?url=https://www.powercheng.fun/articles/d111bf74/&title=JDK1.8新特性"><i class="fab fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener external nofollow noreferrer" href="http://digg.com/submit?url=https://www.powercheng.fun/articles/d111bf74/&title=JDK1.8新特性"><i class="fab fa-digg" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" href="http://www.tumblr.com/share/link?url=https://www.powercheng.fun/articles/d111bf74/&name=JDK1.8新特性&description=&lt;link rel=&#34;stylesheet&#34; type=&#34;text/css&#34; href=&#34;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&#34; /&gt;&lt;div class=&#34;.article-gallery&#34;&gt;&lt;p&gt;关于lambda表达式、streamAPI、Optional和新的日期时间API的总结&lt;/p&gt;"><i class="fab fa-tumblr" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener external nofollow noreferrer" href="https://news.ycombinator.com/submitlink?u=https://www.powercheng.fun/articles/d111bf74/&t=JDK1.8新特性"><i class="fab fa-hacker-news" aria-hidden="true"></i></a></li></ul></div><div id="toc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JDK1-8%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">1.</span> <span class="toc-text">JDK1.8新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#lambda"><span class="toc-number">1.1.</span> <span class="toc-text">lambda</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java8%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.1.1.</span> <span class="toc-text">Java8中常用的函数式接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%E4%BD%BF%E7%94%A8%E4%BE%8B%E5%AD%90"><span class="toc-number">1.1.2.</span> <span class="toc-text">函数式接口使用例子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Stream-API"><span class="toc-number">1.2.</span> <span class="toc-text">Stream API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B5%81%EF%BC%9F"><span class="toc-number">1.2.1.</span> <span class="toc-text">什么是流？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">1.2.2.</span> <span class="toc-text">流的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%9A%84%E6%93%8D%E4%BD%9C%E5%88%86%E7%B1%BB"><span class="toc-number">1.2.3.</span> <span class="toc-text">流的操作分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%9A%84%E6%93%8D%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="toc-number">1.2.4.</span> <span class="toc-text">流的操作过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E6%B5%81%EF%BC%9F"><span class="toc-number">1.2.5.</span> <span class="toc-text">如何获取流？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E9%97%B4%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.6.</span> <span class="toc-text">中间操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%88%E7%AB%AF%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.7.</span> <span class="toc-text">终端操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B2%E6%8E%89%E7%A9%BA%E6%8C%87%E9%92%88%E4%B9%8BOptional"><span class="toc-number">1.3.</span> <span class="toc-text">干掉空指针之Optional</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B0%E7%9A%84%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4API"><span class="toc-number">1.4.</span> <span class="toc-text">新的日期时间API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E7%B1%BB"><span class="toc-number">1.4.1.</span> <span class="toc-text">常用的日期时间类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E6%93%8D%E4%BD%9C%E5%92%8C%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="toc-number">1.4.2.</span> <span class="toc-text">日期操作和格式化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E5%8C%BA"><span class="toc-number">1.4.3.</span> <span class="toc-text">时区</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">1.5.</span> <span class="toc-text">参考资料</span></a></li></ol></li></ol></div></span></div><div class="content index py4"><article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle p-name" itemprop="name headline">JDK1.8新特性</h1><div class="meta"><div class="postdate"><time datetime="2022-03-04T03:12:54.000Z" class="dt-published" itemprop="datePublished">2022-03-04</time> (Updated: <time datetime="2025-11-19T03:04:36.717Z" class="dt-updated" itemprop="dateModified">2025-11-19</time>)</div><div class="article-category"><i class="fa-solid fa-archive"></i> <a class="category-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a></div><div class="article-tag"><i class="fa-solid fa-tag"></i> <a class="p-category" href="/tags/Java/" rel="tag">Java</a></div></div></header><div class="content e-content" itemprop="articleBody"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery"><p>关于lambda表达式、streamAPI、Optional和新的日期时间API的总结</p><span id="more"></span><h1 id="JDK1-8新特性"><a href="#JDK1-8新特性" class="headerlink" title="JDK1.8新特性"></a>JDK1.8新特性</h1><h2 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h2><p>以函数作为方法的参数</p><h3 id="Java8中常用的函数式接口"><a href="#Java8中常用的函数式接口" class="headerlink" title="Java8中常用的函数式接口"></a>Java8中常用的函数式接口</h3><a href="/articles/d111bf74/8Ea31cd87bimage-20220304111057588.png" class="gallery-item"><img src="/articles/d111bf74/8Ea31cd87bimage-20220304111057588.png" title="image-20220304111057588"></a><h3 id="函数式接口使用例子"><a href="#函数式接口使用例子" class="headerlink" title="函数式接口使用例子"></a>函数式接口使用例子</h3><a href="/articles/d111bf74/efD9F7a5BCimage-20220304110927875.png" class="gallery-item"><img src="/articles/d111bf74/efD9F7a5BCimage-20220304110927875.png" title="image-20220304110927875"></a><h2 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a>Stream API</h2><h3 id="什么是流？"><a href="#什么是流？" class="headerlink" title="什么是流？"></a>什么是流？</h3><p>流是Java8引入的全新概念，它用来处理集合中的数据，暂且可以把它理解为一种【高级集合】。 众所周知，集合操作非常麻烦，若要对集合进行筛选、投影，需要写大量的代码，而流是以声明的形式操作集合，它就像SQL语句，我们只需告诉流需要对集合进行什么操作，它就会自动进行操作，并将执行结果交给你，无需我们自己手写代码。 因此，流的集合操作对我们来说是透明的，我们只需向流下达命令，它就会自动把我们想要的结果给我们。由于操作过程完全由Java处理，因此它可以根据当前硬件环境选择最优的方法处理，我们也无需编写复杂又容易出错的多线程代码了。</p><h3 id="流的特点"><a href="#流的特点" class="headerlink" title="流的特点"></a>流的特点</h3><ol><li>【只能遍历一次】 我们可以把流想象成一条流水线，流水线的源头是我们的数据源(一个集合)，数据源中的元素依次被输送到流水线上，我们可以在流水线上对元素进行各种操作。 一旦元素走到了流水线的另一头，那么这些元素就被“消费掉了”，我们无法再对这个流进行操作。当然，我们可以从数据源那里再获得一个新的流重新遍历一遍。</li><li>采用【内部迭代】方式 若要对集合进行处理，则需我们手写处理代码，这就叫做外部迭代。 而要对流进行处理，我们只需告诉流我们需要什么结果，处理过程由流自行完成，这就称为内部迭代。</li></ol><h3 id="流的操作分类"><a href="#流的操作分类" class="headerlink" title="流的操作分类"></a>流的操作分类</h3><p>流的操作分为两种，分别为中间操作和终端操作。</p><ol><li>中间操作 当数据源中的数据上了流水线后，这个过程对数据进行的所有操作都称为“中间操作”。 【中间操作仍然会返回一个流对象】，因此多个中间操作可以串连起来形成一个流水线。</li><li>终端操作 当所有的中间操作完成后，若要将数据从流水线上拿下来，则需要执行终端操作。 【终端操作将返回一个执行结果】，这就是你想要的数据。</li></ol><p>中间操作和终端操作汇总</p><a href="/articles/d111bf74/F57C8a92eFimage-20220304111118157.png" class="gallery-item"><img src="/articles/d111bf74/F57C8a92eFimage-20220304111118157.png" title="image-20220304111118157"></a><h3 id="流的操作过程"><a href="#流的操作过程" class="headerlink" title="流的操作过程"></a>流的操作过程</h3><ol><li>准备数据源</li><li>执行中间操作，可以有多个中间操作</li><li>执行终端操作，本次流执行结束，获取结果</li></ol><h3 id="如何获取流？"><a href="#如何获取流？" class="headerlink" title="如何获取流？"></a>如何获取流？</h3><ol><li><p>通过集合【最常用】</p><p>通过集合的Stream方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; people = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Stream&lt;Person&gt; stream = people.stream();</span><br></pre></td></tr></table></figure></li><li><p>通过数组</p><p>通过数组的Arrays的stream静态方法可以获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] strings = <span class="keyword">new</span> String[]&#123;&#125;;</span><br><span class="line">Stream&lt;String&gt; stream = Arrays.stream(strings);</span><br></pre></td></tr></table></figure></li><li><p>值</p><p>直接将几个值变为stream流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stringStream = Stream.of(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>文件，注意这里可不是文件的IO流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(Stream lines = Files.lines(Paths.get(<span class="string">&quot;test.txt&quot;</span>), Charset.defaultCharset()))&#123;</span><br><span class="line">    <span class="comment">//可对lines做一些操作</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>iterate，无限流</p><p>返回通过将函数f迭代应用到初始元素seed产生的无限顺序有序Stream ，产生由seed 、 f(seed) 、 f(f(seed))等组成的Stream 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream.iterate(<span class="number">0</span>, n -&gt; n + <span class="number">2</span>).limit(<span class="number">10</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure></li></ol><h3 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h3><p>常用 filter、map、limit、skip、sorted、distinct</p><ol><li><p>筛选 filter：简而言之就是把符合括号中条件的值筛选出来</p><p>filter 函数接收一个Lambda表达式作为参数，该表达式返回boolean，在执行过程中，流将元素逐一输送给filter，并筛选出执行结果为true的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 筛选出不为空的字符串</span></span><br><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;hc&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;zs&quot;</span>, <span class="string">&quot;H&quot;</span>, <span class="string">&quot;I&quot;</span>);</span><br><span class="line">strings.stream().filter(e -&gt; !e.isEmpty()).forEach(System.out::println);</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">hc</span><br><span class="line">zs</span><br><span class="line">H</span><br><span class="line">I</span><br></pre></td></tr></table></figure></li><li><p>去重 distinct：就是去掉重复的结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">numbers.stream().distinct().forEach(System.out::println);</span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure></li><li><p>截取 limit：截取前n个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">numbers.stream().limit(<span class="number">2</span>).forEach(System.out::println);</span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure></li><li><p>跳过 skip：跳过前n个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">numbers.stream().skip(<span class="number">2</span>).forEach(System.out::println);</span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure></li><li><p>映射 map：将流中的每个元素按照map的括号中lambda表达式的逻辑进行计算，然后变成计算后的样子。对流中的【每个元素】执行一个函数，使得【元素转换成另一种类型输出】。流会将每一个元素输送给map函数，并执行map中的Lambda表达式，最后将执行结果存入一个新的流中。 如，获取每个人的姓名(实则是将Perosn类型转换成String类型)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; personList = getPersonList();</span><br><span class="line">List&lt;String&gt; collect = personList.stream().map(Person::getName).collect(Collectors.toList());</span><br></pre></td></tr></table></figure></li><li><p>排序 sorted，对流进行排序 默认自然序升序，想降序的话使用 sorted(Comparator.reverseOrder())</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">numbers.stream().sorted().forEach(System.out::println);</span><br><span class="line"><span class="comment">// 返回值</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure></li><li><p>展平 flatMap：当你想要让一个值转换为另一个值的时候可以用map，但是当想要用一个值获取多个值，然后还想把这多个值都装到一个list里面，就该考虑用flatMap了，展平map！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * flatMap，当你想要让一个值转换为另一个值的时候可以用map，但是当想要用一个值获取多个值，然后还想</span></span><br><span class="line"><span class="comment"> * 把这多个值都装到一个list里面，就该考虑用flatMap了，展平map！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">flatMapOperation</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 场景：列出list中各不相同的单词</span></span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    list.add(<span class="string">&quot;I am a boy&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;I love the girl&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;But the girl loves another girl&quot;</span>);</span><br><span class="line">    <span class="comment">// 先切分句子得出每个单词，切分肯定会得到若干个String[]，怎么把这么多的String[]整合到一个Stream&lt;String&gt;里面呢？</span></span><br><span class="line">    <span class="comment">// 使用flatMap，展平为Stream&lt;String&gt;</span></span><br><span class="line">    <span class="comment">// 然后去重，再合并为一个list</span></span><br><span class="line">    List&lt;String&gt; collect = list.stream().map(line -&gt; line.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">            .flatMap(Arrays::stream)</span><br><span class="line">            .distinct()</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    collect.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="终端操作"><a href="#终端操作" class="headerlink" title="终端操作"></a>终端操作</h3><ol><li><p>常用 allMatch、anyMatch、noneMatch、findAny、findFirst</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">endOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="comment">// allMatch 是否匹配所有元素，判断流中所有元素是否都符合指定条件</span></span><br><span class="line">    <span class="comment">// 流中元素是否都小于10 true</span></span><br><span class="line">    System.out.println(numbers.stream().allMatch(num -&gt; num &lt; <span class="number">10</span>));</span><br><span class="line">    <span class="comment">// anyMatch 用于判断流中是否存在至少一个元素满足指定的条件</span></span><br><span class="line">    <span class="comment">// 流中元素至少有一个是等于5的 true</span></span><br><span class="line">    System.out.println(numbers.stream().anyMatch(num -&gt; num == <span class="number">5</span>));</span><br><span class="line">    <span class="comment">// noneMatch 与allMatch相反，判断流中所有元素是否都不符合指定条件</span></span><br><span class="line">    <span class="comment">// 流中元素都不小于10 false</span></span><br><span class="line">    System.out.println(numbers.stream().noneMatch(num -&gt; num &lt; <span class="number">10</span>));</span><br><span class="line">    <span class="comment">// findAny 从流中随便选一个元素出来，返回的是Optional类型的元素</span></span><br><span class="line">    Optional&lt;Integer&gt; any = numbers.stream().findAny();</span><br><span class="line">    System.out.println(any);</span><br><span class="line">    <span class="comment">// findFirst 取流中第一个元素 返回的是Optional类型的元素</span></span><br><span class="line">    System.out.println(numbers.stream().findFirst());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>归约：指将集合中的元素经过指定运算，折叠成一个元素输出，如：求平均值、最值等等，在流中，reduce能够实现归约。</p><p>reduce接收两个参数：1.初始值 2.进行归约操作的lambda表达式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line"><span class="comment">// 第一个参数的含义：表示reduce计算的初始值是0</span></span><br><span class="line"><span class="comment">// 第二个参数的含义：是一个两个参数的lambda表达式，表示要进行的归约操作</span></span><br><span class="line"><span class="comment">// reduce会把流中元素两两输给lambda表达式，最后将计算出累加之和</span></span><br><span class="line">Integer reduce = numbers.stream().reduce(<span class="number">0</span>, (num1, num2) -&gt; num1 + num2);</span><br><span class="line"><span class="comment">// 上面的还可以这样写，使用Integer自带的sum方法，这么着得话，Integer的min，max方法也都可以用</span></span><br><span class="line">Integer reduce1 = numbers.stream().reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line">System.out.println(reduce);</span><br><span class="line"><span class="comment">// 求numbers中的最大值，这里不加第一个参数了，直接进行函数里的计算</span></span><br><span class="line">Optional&lt;Integer&gt; reduce2 = numbers.stream().reduce(Integer::min);</span><br><span class="line">System.out.println(reduce2);</span><br></pre></td></tr></table></figure></li><li><p>数值流：Stream API提供了三种数值流：IntStream、DoubleStream、LongStream</p><p>也提供了将普通流转换成数值流的三种方法：mapToInt、mapToDouble、mapToLong，采用reduce进行数值操作会涉及到基本数值类型和引用数值类型之间的装箱、拆箱操作，因此效率较低。当流操作为纯数值操作时，使用【数值流能获得较高的效率】。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IntStream intStream = numbers.stream().mapToInt(num -&gt; num);</span><br><span class="line"><span class="comment">// 每种数值流也都有计算函数如max、min、sum</span></span><br><span class="line">OptionalInt max = numbers.stream().mapToInt(num -&gt; num).max();</span><br><span class="line">System.out.println(max);</span><br></pre></td></tr></table></figure></li><li><p>collect</p><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.notion.so/288683ab43e840eb8d2684202261609f">Collectors 类的静态工厂方法</a></p></li></ol><h2 id="干掉空指针之Optional"><a href="#干掉空指针之Optional" class="headerlink" title="干掉空指针之Optional"></a>干掉空指针之Optional</h2><p>参考：</p><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://juejin.cn/post/7019908756767145997">掘金</a></p><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://juejin.cn/post/7014497511700168740">掘金</a></p><h2 id="新的日期时间API"><a href="#新的日期时间API" class="headerlink" title="新的日期时间API"></a>新的日期时间API</h2><h3 id="常用的日期时间类"><a href="#常用的日期时间类" class="headerlink" title="常用的日期时间类"></a>常用的日期时间类</h3><p>Java8日期时间类相关API说明，涉及到localDate、localTime、localDateTime、instant、duration、period</p><ol><li><p>LocalDate</p><p>LocalDate类表示一个具体的日期，但不包含具体时间，也不包含时区信息。可以通过LocalDate的静态方法of()创建一个实例，LocalDate也包含一些方法用来获取年份，月份，天，星期几等。</p><ul><li><p>代码演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LocalDate API使用</span></span><br><span class="line"><span class="comment"> * LocalDate类表示一个具体的日期，但不包含具体时间，也不包含时区信息。</span></span><br><span class="line"><span class="comment"> * 可以通过LocalDate的静态方法of()创建一个实例</span></span><br><span class="line"><span class="comment"> * LocalDate也包含一些方法用来获取年份，月份，天，星期几等</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">localDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化日期 2021-10-02</span></span><br><span class="line">    LocalDate localDate = LocalDate.of(<span class="number">2021</span>, <span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 也可以通过静态方法now() 来获取当前日期</span></span><br><span class="line">    LocalDate now = LocalDate.now();</span><br><span class="line">    System.out.println(<span class="string">&quot;当前日期：&quot;</span> + now);</span><br><span class="line">    <span class="comment">// 获取年份</span></span><br><span class="line">    <span class="keyword">int</span> year = localDate.getYear();</span><br><span class="line">    <span class="comment">// 获取月份枚举</span></span><br><span class="line">    Month month = localDate.getMonth();</span><br><span class="line">    <span class="comment">// 获取当前时间是当前月中的第几天</span></span><br><span class="line">    <span class="keyword">int</span> dayOfMonth = localDate.getDayOfMonth();</span><br><span class="line">    <span class="comment">// 获取当前日期是本周第几天 也就是周几 返回的是一个week的枚举</span></span><br><span class="line">    DayOfWeek dayOfWeek = localDate.getDayOfWeek();</span><br><span class="line">    <span class="comment">// 获取当前月一共有几天</span></span><br><span class="line">    <span class="keyword">int</span> lengthOfMonth = localDate.lengthOfMonth();</span><br><span class="line">    <span class="comment">// 是否为闰年</span></span><br><span class="line">    <span class="keyword">boolean</span> leapYear = localDate.isLeapYear();</span><br><span class="line">    System.out.println(<span class="string">&quot;当前年份：&quot;</span> + year + <span class="string">&quot; 当前月份：&quot;</span> + month + <span class="string">&quot; 当前天是当前月的第几天：&quot;</span> + dayOfMonth</span><br><span class="line">    + <span class="string">&quot; 当前天是本周第几天：&quot;</span> + dayOfWeek + <span class="string">&quot; 当前月共多少天：&quot;</span> + lengthOfMonth + <span class="string">&quot; 是否为闰年：&quot;</span> + leapYear);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当前日期：<span class="number">2021</span>-<span class="number">10</span>-<span class="number">05</span></span><br><span class="line">当前年份：<span class="number">2021</span> 当前月份：OCTOBER 当前天是当前月的第几天：<span class="number">2</span> 当前天是本周第几天：SATURDAY 当前月共多少天：<span class="number">31</span> 是否为闰年：<span class="keyword">false</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>LocalTime</p><p>LocalTime和LocalDate类似，LocalTime是针对具体时间来说的，比如时分秒；LocalDate是针对日期的，比如年月日</p><ul><li><p>代码演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LocalTime API 使用</span></span><br><span class="line"><span class="comment"> * LocalTime和LocalDate类似，LocalTime是针对具体时间来说的，比如时分秒；LocalDate是针对日期的，比如年月日</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">localTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LocalTime localTime = LocalTime.of(<span class="number">22</span>, <span class="number">23</span>, <span class="number">16</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;LocalTime：&quot;</span> + localTime);</span><br><span class="line">    <span class="keyword">int</span> hour = localTime.getHour();</span><br><span class="line">    <span class="keyword">int</span> minute = localTime.getMinute();</span><br><span class="line">    <span class="keyword">int</span> second = localTime.getSecond();</span><br><span class="line">    System.out.println(<span class="string">&quot;时分秒：&quot;</span> + hour + <span class="string">&quot;:&quot;</span> + minute + <span class="string">&quot;:&quot;</span> + second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LocalTime：22:23:16</span><br><span class="line">时分秒：22:23:16</span><br></pre></td></tr></table></figure></li></ul></li><li><p>LocalDateTime</p><p>LocalDateTime是LocalDate和LocalTime的结合，拥有年月日时分秒</p><ul><li><p>代码演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LocalDateTime API使用</span></span><br><span class="line"><span class="comment"> * LocalDateTime是LocalDate和LocalTime的结合，拥有年月日时分秒</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">localDateTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过年月日时分秒创建</span></span><br><span class="line">    LocalDateTime of = LocalDateTime.of(<span class="number">2021</span>, <span class="number">10</span>, <span class="number">2</span>, <span class="number">22</span>, <span class="number">30</span>, <span class="number">16</span>);</span><br><span class="line">    <span class="comment">// 也可以通过localDate和localTime对象创建</span></span><br><span class="line">    LocalDate localDate = LocalDate.of(<span class="number">2021</span>, <span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line">    LocalTime localTime = LocalTime.of(<span class="number">22</span>, <span class="number">23</span>, <span class="number">16</span>);</span><br><span class="line">    LocalDateTime localDateTime = LocalDateTime.of(localDate, localTime);</span><br><span class="line">    <span class="comment">// 也可以通过localDate.atTime()</span></span><br><span class="line">    LocalDateTime atTime = localDate.atTime(localTime);</span><br><span class="line">    <span class="comment">// 也可以通过localTime.atDate()</span></span><br><span class="line">    LocalDateTime atDate = localTime.atDate(localDate);</span><br><span class="line">    <span class="comment">// localDateTime也可以取出localDate和localTime</span></span><br><span class="line">    LocalDate toLocalDate = localDateTime.toLocalDate();</span><br><span class="line">    LocalTime toLocalTime = localDateTime.toLocalTime();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Instant</p><p>Instant用于表示一个时间戳，它与我们常使用的System.currentTimeMillis()有些类似，不过Instant可以精确到纳秒（Nano-Second），System.currentTimeMillis()方法只精确到毫秒（Milli-Second）。如果查看Instant源码，发现它的内部使用了两个常量，seconds表示从1970-01-01 00:00:00开始到现在的秒数，nanos表示纳秒部分（nanos的值不会超过999,999,999）。Instant除了使用now()方法创建外，还可以通过ofEpochSecond方法创建</p><ul><li><p>代码演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Instant用于表示一个时间戳，它与我们常使用的System.currentTimeMillis()有些类似</span></span><br><span class="line"><span class="comment"> * 不过Instant可以精确到纳秒（Nano-Second），System.currentTimeMillis()方法只精确到毫秒（Milli-Second）</span></span><br><span class="line"><span class="comment"> * 如果查看Instant源码，发现它的内部使用了两个常量，seconds表示从1970-01-01 00:00:00开始到现在的秒数，nanos表示纳秒部分（nanos的值不会超过999,999,999）</span></span><br><span class="line"><span class="comment"> * Instant除了使用now()方法创建外，还可以通过ofEpochSecond方法创建：</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">instant</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第一个参数是秒，第二个参数是纳秒</span></span><br><span class="line">    <span class="comment">// 下面代码表示从1970-01-01 00:00:00开始后两分钟的10万纳秒的时刻</span></span><br><span class="line">    Instant instant = Instant.ofEpochSecond(<span class="number">120</span>, <span class="number">100000</span>);</span><br><span class="line">    System.out.println(instant);</span><br><span class="line"></span><br><span class="line">    Instant now = Instant.now();</span><br><span class="line">    System.out.println(now);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1970</span>-<span class="number">01</span>-01T00:<span class="number">02</span>:<span class="number">00.</span>000100Z</span><br><span class="line"><span class="number">2021</span>-<span class="number">10</span>-05T12:<span class="number">18</span>:<span class="number">14.</span>931Z</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Duration</p><p>Duration的内部实现与Instant类似，也是包含两部分：seconds表示秒，nanos表示纳秒。两者的区别是Instant用于表示一个时间戳（或者说是一个时间点），而Duration表示一个时间段，所以Duration类中不包含now()静态方法。可以通过Duration.between()方法创建Duration对象。</p><ul><li><p>代码演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Duration的内部实现与Instant类似，也是包含两部分：seconds表示秒，nanos表示纳秒。</span></span><br><span class="line"><span class="comment"> * 两者的区别是Instant用于表示一个时间戳（或者说是一个时间点），而Duration表示一个时间段，</span></span><br><span class="line"><span class="comment"> * 所以Duration类中不包含now()静态方法。可以通过Duration.between()方法创建Duration对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">duration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前时间</span></span><br><span class="line">    LocalDateTime from = LocalDateTime.of(<span class="number">2021</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">41</span>, <span class="number">16</span>);</span><br><span class="line">    <span class="comment">// 火车发车时间</span></span><br><span class="line">    LocalDateTime to = LocalDateTime.of(<span class="number">2021</span>, <span class="number">10</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">58</span>, <span class="number">00</span>);</span><br><span class="line">    <span class="comment">// 看看距离火车发车还有多长时间2333333</span></span><br><span class="line">    Duration duration = Duration.between(from, to);</span><br><span class="line">    <span class="keyword">long</span> days = duration.toDays();</span><br><span class="line">    <span class="keyword">long</span> hours = duration.toHours();</span><br><span class="line">    <span class="keyword">long</span> minutes = duration.toMinutes();</span><br><span class="line">    <span class="keyword">long</span> seconds = duration.getSeconds();</span><br><span class="line">    <span class="keyword">long</span> millis = duration.toMillis();</span><br><span class="line">    <span class="keyword">long</span> nanos = duration.toNanos();</span><br><span class="line">    System.out.println(<span class="string">&quot;距离发车还有：&quot;</span> + days + <span class="string">&quot;天&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;距离发车还有：&quot;</span> + hours + <span class="string">&quot;小时&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;距离发车还有：&quot;</span> + minutes + <span class="string">&quot;分钟&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;距离发车还有：&quot;</span> + seconds + <span class="string">&quot;秒&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;距离发车还有：&quot;</span> + millis + <span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;距离发车还有：&quot;</span> + nanos + <span class="string">&quot;纳秒&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他创建duration对象的方法，第一个参数是时长，第二个参数是时间单位</span></span><br><span class="line">    Duration of = Duration.of(<span class="number">5</span>, ChronoUnit.DAYS);</span><br><span class="line">    System.out.println(of.toDays());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">距离发车还有：<span class="number">2</span>天</span><br><span class="line">距离发车还有：<span class="number">64</span>小时</span><br><span class="line">距离发车还有：<span class="number">3856</span>分钟</span><br><span class="line">距离发车还有：<span class="number">231404</span>秒</span><br><span class="line">距离发车还有：<span class="number">231404000</span>毫秒</span><br><span class="line">距离发车还有：<span class="number">231404000000000</span>纳秒</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>Period</p><p>Period在概念上和Duration类似，区别在于Period是以年月日来衡量一个时间段</p><ul><li><p>代码演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Period在概念上和Duration类似，区别在于Period是以年月日来衡量一个时间段</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">period</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 两年六个月三天</span></span><br><span class="line">    Period period = Period.of(<span class="number">2</span>, <span class="number">6</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="comment">// 形容一段时间</span></span><br><span class="line">    Period between = Period.between(LocalDate.of(<span class="number">2021</span>, <span class="number">10</span>, <span class="number">4</span>), LocalDate.of(<span class="number">2023</span>, <span class="number">10</span>, <span class="number">4</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="日期操作和格式化"><a href="#日期操作和格式化" class="headerlink" title="日期操作和格式化"></a>日期操作和格式化</h3><ol><li><p>日期相关操作，加减日期，修改日期等等</p><ul><li><p>代码演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 日期操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dateOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 简单操作 - 直接改日期</span></span><br><span class="line">    LocalDate localDate = LocalDate.of(<span class="number">2021</span>, <span class="number">10</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="comment">// 将日期中的年改为2022年</span></span><br><span class="line">    LocalDate withYear = localDate.withYear(<span class="number">2022</span>);</span><br><span class="line">    <span class="comment">// 将月份改为12月</span></span><br><span class="line">    LocalDate withMonth = localDate.withMonth(<span class="number">12</span>);</span><br><span class="line">    <span class="comment">// 修改天</span></span><br><span class="line">    LocalDate withDayOfMonth = localDate.withDayOfMonth(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 改为2022年12月02日</span></span><br><span class="line">    LocalDate date = localDate.withYear(<span class="number">2022</span>).withMonth(<span class="number">12</span>).withDayOfMonth(<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;withYear：&quot;</span> + withYear);</span><br><span class="line">    System.out.println(<span class="string">&quot;withMonth：&quot;</span> + withMonth);</span><br><span class="line">    System.out.println(<span class="string">&quot;withDayOfMonth：&quot;</span> + withDayOfMonth);</span><br><span class="line">    System.out.println(<span class="string">&quot;date：&quot;</span> + date);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 简单操作 - 日期加减</span></span><br><span class="line">    <span class="comment">// 加两年</span></span><br><span class="line">    LocalDate plusYears = localDate.plusYears(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 减去俩月</span></span><br><span class="line">    LocalDate minusMonths = localDate.minusMonths(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 加五天</span></span><br><span class="line">    LocalDate plus = localDate.plus(<span class="number">2</span>, ChronoUnit.DAYS);</span><br><span class="line">    System.out.println(<span class="string">&quot;plusYears：&quot;</span> + plusYears);</span><br><span class="line">    System.out.println(<span class="string">&quot;minusMonths：&quot;</span> + minusMonths);</span><br><span class="line">    System.out.println(<span class="string">&quot;plus：&quot;</span> + plus);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更灵活的操作，使用with方法+TemporalAdjuster，TemporalAdjusters类中包含了很多静态方法可以直接使用</span></span><br><span class="line">    <span class="comment">// 返回下一个距离当前日期最近的星期日</span></span><br><span class="line">    LocalDate with1 = localDate.with(TemporalAdjusters.nextOrSame(DayOfWeek.SUNDAY));</span><br><span class="line">    <span class="comment">// 返回本月最后一个星期六</span></span><br><span class="line">    LocalDate with2 = localDate.with(TemporalAdjusters.lastInMonth(DayOfWeek.SATURDAY));</span><br><span class="line">    System.out.println(<span class="string">&quot;with1：&quot;</span> + with1);</span><br><span class="line">    System.out.println(<span class="string">&quot;with2：&quot;</span> + with2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义操作日期 - 给定一个日期，计算该日期的下一个工作日（就是跳过星期六和星期天）</span></span><br><span class="line">    LocalDate testDate = LocalDate.of(<span class="number">2021</span>, <span class="number">10</span>, <span class="number">4</span>);</span><br><span class="line">    LocalDate with3 = testDate.with(temporal -&gt; &#123;</span><br><span class="line">        DayOfWeek dayOfWeek = DayOfWeek.of(temporal.get(ChronoField.DAY_OF_WEEK));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 正常情况，每次增加一天</span></span><br><span class="line">        <span class="keyword">int</span> dayToAdd = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是星期五，加三天</span></span><br><span class="line">        <span class="keyword">if</span> (dayOfWeek == DayOfWeek.FRIDAY) &#123;</span><br><span class="line">            dayToAdd = <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是周六，加两天</span></span><br><span class="line">        <span class="keyword">if</span> (dayOfWeek == DayOfWeek.SATURDAY) &#123;</span><br><span class="line">            dayToAdd = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> temporal.plus(dayToAdd, ChronoUnit.DAYS);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;with3：&quot;</span> + with3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">withYear：<span class="number">2022</span>-<span class="number">10</span>-<span class="number">04</span></span><br><span class="line">withMonth：<span class="number">2021</span>-<span class="number">12</span>-<span class="number">04</span></span><br><span class="line">withDayOfMonth：<span class="number">2021</span>-<span class="number">10</span>-<span class="number">02</span></span><br><span class="line">date：<span class="number">2022</span>-<span class="number">12</span>-<span class="number">02</span></span><br><span class="line">plusYears：<span class="number">2023</span>-<span class="number">10</span>-<span class="number">04</span></span><br><span class="line">minusMonths：<span class="number">2021</span>-08-<span class="number">04</span></span><br><span class="line">plus：<span class="number">2021</span>-<span class="number">10</span>-<span class="number">06</span></span><br><span class="line">with1：<span class="number">2021</span>-<span class="number">10</span>-<span class="number">10</span></span><br><span class="line">with2：<span class="number">2021</span>-<span class="number">10</span>-<span class="number">30</span></span><br><span class="line">with3：<span class="number">2021</span>-<span class="number">10</span>-<span class="number">05</span></span><br></pre></td></tr></table></figure></li></ul><p>对于更灵活的操作，需要使用with方法+TemporalAdjuster，TemporalAdjusters类中包含了很多静态方法可以直接使用，TemporalAdjusters类中包含了很多静态方法可以直接使用，下面的表格列出了一些方法：</p><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.notion.so/4226a0d513a149b8a5a674b21f73be0b">TemporalAdjusters的静态方法</a></p></li><li><p>日期格式化</p><p>新的日期API中提供了一个DateTimeFormatter类用于处理日期格式化操作，它被包含在java.time.format包中，Java 8的日期类有一个format()方法用于将日期格式化为字符串。</p><p>该方法接收一个DateTimeFormatter类型参数</p><ul><li><p>代码演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 格式化日期</span></span><br><span class="line"><span class="comment"> * 新的日期API中提供了一个DateTimeFormatter类用于处理日期格式化操作</span></span><br><span class="line"><span class="comment"> * 它被包含在java.time.format包中，Java 8的日期类有一个format()方法用于将日期格式化为字符串</span></span><br><span class="line"><span class="comment"> * 该方法接收一个DateTimeFormatter类型参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dateFormat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 2021-10-04T22:34:19.059</span></span><br><span class="line">    LocalDateTime now = LocalDateTime.now();</span><br><span class="line">    <span class="comment">// 20211004</span></span><br><span class="line">    String basicIsoDate = now.format(DateTimeFormatter.BASIC_ISO_DATE);</span><br><span class="line">    <span class="comment">// 2021-10-04</span></span><br><span class="line">    String isoLocalDate = now.format(DateTimeFormatter.ISO_LOCAL_DATE);</span><br><span class="line">    <span class="comment">// 22:34:19.059</span></span><br><span class="line">    String isoLocalTime = now.format(DateTimeFormatter.ISO_LOCAL_TIME);</span><br><span class="line">    <span class="comment">// 自定义</span></span><br><span class="line">    String customizeDate = now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd&quot;</span>));</span><br><span class="line">    String customizeDateTime = now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;今天是：yyyy年 MMMM dd日 E&quot;</span>, Locale.CHINESE));</span><br><span class="line">    System.out.println(<span class="string">&quot;now：&quot;</span> + now);</span><br><span class="line">    System.out.println(<span class="string">&quot;basicIsoDate：&quot;</span> + basicIsoDate);</span><br><span class="line">    System.out.println(<span class="string">&quot;isoLocalDate：&quot;</span> + isoLocalDate);</span><br><span class="line">    System.out.println(<span class="string">&quot;isoLocalTime：&quot;</span> + isoLocalTime);</span><br><span class="line">    System.out.println(<span class="string">&quot;customizeDate：&quot;</span> + customizeDate);</span><br><span class="line">    System.out.println(<span class="string">&quot;customizeDateTime：&quot;</span> + customizeDateTime);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将字符串解析成日期对象</span></span><br><span class="line">    String strDate = <span class="string">&quot;2021-10-05&quot;</span>;</span><br><span class="line">    String strDateTime = <span class="string">&quot;2021-10-05 19:49:16&quot;</span>;</span><br><span class="line">    LocalDate date = LocalDate.parse(strDate, DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd&quot;</span>));</span><br><span class="line">    LocalDateTime dateTime = LocalDateTime.parse(strDateTime, DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;date: &quot;</span> + date);</span><br><span class="line">    System.out.println(<span class="string">&quot;dateTime: &quot;</span> + dateTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">now：<span class="number">2021</span>-<span class="number">10</span>-05T20:<span class="number">41</span>:<span class="number">47.926</span></span><br><span class="line">basicIsoDate：<span class="number">20211005</span></span><br><span class="line">isoLocalDate：<span class="number">2021</span>-<span class="number">10</span>-<span class="number">05</span></span><br><span class="line">isoLocalTime：<span class="number">20</span>:<span class="number">41</span>:<span class="number">47.926</span></span><br><span class="line">customizeDate：<span class="number">2021</span>-<span class="number">10</span>-<span class="number">05</span></span><br><span class="line">customizeDateTime：今天是：<span class="number">2021</span>年 十月 <span class="number">05</span>日 星期二</span><br><span class="line">date: <span class="number">2021</span>-<span class="number">10</span>-<span class="number">05</span></span><br><span class="line">dateTime: <span class="number">2021</span>-<span class="number">10</span>-05T19:<span class="number">49</span>:<span class="number">16</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="时区"><a href="#时区" class="headerlink" title="时区"></a>时区</h3><p>Java 8中的时区操作被很大程度上简化了，新的时区类java.time.ZoneId是原有的java.util.TimeZone类的替代品。ZoneId对象可以通过ZoneId.of()方法创建，也可以通过ZoneId.systemDefault()获取系统默认时区</p><ul><li><p>代码演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Java 8中的时区操作被很大程度上简化了</span></span><br><span class="line"><span class="comment"> * 新的时区类java.time.ZoneId是原有的java.util.TimeZone类的替代品。</span></span><br><span class="line"><span class="comment"> * ZoneId对象可以通过ZoneId.of()方法创建，也可以通过ZoneId.systemDefault()获取系统默认时区：</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">zoneId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取系统默认时区</span></span><br><span class="line">    ZoneId zoneId = ZoneId.systemDefault();</span><br><span class="line">    <span class="comment">// 自己创建时区</span></span><br><span class="line">    ZoneId of = ZoneId.of(<span class="string">&quot;Asia/Shanghai&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;of: &quot;</span> + of);</span><br><span class="line">    System.out.println(<span class="string">&quot;zoneId: &quot;</span> + zoneId);</span><br><span class="line">    <span class="comment">// of参数里面不知道传啥值比较合理？可以通过ZoneId.getAvailableZoneIds()来获取可选择的ZoneId</span></span><br><span class="line">    <span class="comment">// 也就是所有合法的“区域/城市”字符串</span></span><br><span class="line">    Set&lt;String&gt; availableZoneIds = ZoneId.getAvailableZoneIds();</span><br><span class="line">    System.out.println(<span class="string">&quot;availableZoneIds: &quot;</span> + availableZoneIds);</span><br><span class="line">    <span class="comment">// 有了ZoneId，我们就可以将一个LocalDate、LocalTime或LocalDateTime对象转化为ZonedDateTime对象</span></span><br><span class="line">    LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">    ZonedDateTime zonedDateTime = ZonedDateTime.of(localDateTime, zoneId);</span><br><span class="line">    System.out.println(<span class="string">&quot;zonedDateTime: &quot;</span> + zonedDateTime);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 另一种表示时区的方式是使用ZoneOffset，它是以当前时间和世界标准时间（UTC）/格林威治时间（GMT）的偏差来计算</span></span><br><span class="line">    ZoneOffset zoneOffset = ZoneOffset.of(<span class="string">&quot;+09:00&quot;</span>);</span><br><span class="line">    LocalDateTime now = LocalDateTime.now();</span><br><span class="line">    OffsetDateTime offsetDateTime = OffsetDateTime.of(localDateTime, zoneOffset);</span><br><span class="line">    System.out.println(<span class="string">&quot;offsetDateTime: &quot;</span> + offsetDateTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">of: Asia/Shanghai</span><br><span class="line">zoneId: Asia/Shanghai</span><br><span class="line">availableZoneIds: [Asia/Aden, America/Cuiaba, Etc/GMT+9, Etc/GMT+8, Africa/Nairobi, America/Marigot, Asia/Aqtau, Pacific/Kwajalein, America/El_Salvador, Asia/Pontianak, Africa/Cairo, Pacific/Pago_Pago, Africa/Mbabane, Asia/Kuching, Pacific/Honolulu, Pacific/Rarotonga, America/Guatemala, Australia/Hobart, Europe/London, America/Belize, America/Panama, Asia/Chungking, America/Managua, America/Indiana/Petersburg, Asia/Yerevan, Europe/Brussels, GMT, Europe/Warsaw, America/Chicago, Asia/Kashgar, Chile/Continental, Pacific/Yap, CET, Etc/GMT-1, Etc/GMT-0, Europe/Jersey, America/Tegucigalpa, Etc/GMT-5, Europe/Istanbul, America/Eirunepe, Etc/GMT-4, America/Miquelon, Etc/GMT-3, Europe/Luxembourg, Etc/GMT-2, Etc/GMT-9, America/Argentina/Catamarca, Etc/GMT-8, Etc/GMT-7, Etc/GMT-6, Europe/Zaporozhye, Canada/Yukon, Canada/Atlantic, Atlantic/St_Helena, Australia/Tasmania, Libya, Europe/Guernsey, America/Grand_Turk, US/Pacific-New, Asia/Samarkand, America/Argentina/Cordoba, Asia/Phnom_Penh, Africa/Kigali, Asia/Almaty, US/Alaska, Asia/Dubai, Europe/Isle_of_Man, America/Araguaina, Cuba, Asia/Novosibirsk, America/Argentina/Salta, Etc/GMT+3, Africa/Tunis, Etc/GMT+2, Etc/GMT+1, Pacific/Fakaofo, Africa/Tripoli, Etc/GMT+0, Israel, Africa/Banjul, Etc/GMT+7, Indian/Comoro, Etc/GMT+6, Etc/GMT+5, Etc/GMT+4, Pacific/Port_Moresby, US/Arizona, Antarctica/Syowa, Indian/Reunion, Pacific/Palau, Europe/Kaliningrad, America/Montevideo, Africa/Windhoek, Asia/Karachi, Africa/Mogadishu, Australia/Perth, Brazil/East, Etc/GMT, Asia/Chita, Pacific/Easter, Antarctica/Davis, Antarctica/McMurdo, Asia/Macao, America/Manaus, Africa/Freetown, Europe/Bucharest, Asia/Tomsk, America/Argentina/Mendoza, Asia/Macau, Europe/Malta, Mexico/BajaSur, Pacific/Tahiti, Africa/Asmera, Europe/Busingen, America/Argentina/Rio_Gallegos, Africa/Malabo, Europe/Skopje, America/Catamarca, America/Godthab, Europe/Sarajevo, Australia/ACT, GB-Eire, Africa/Lagos, America/Cordoba, Europe/Rome, Asia/Dacca, Indian/Mauritius, Pacific/Samoa, America/Regina, America/Fort_Wayne, America/Dawson_Creek, Africa/Algiers, Europe/Mariehamn, America/St_Johns, America/St_Thomas, Europe/Zurich, America/Anguilla, Asia/Dili, America/Denver, Africa/Bamako, Europe/Saratov, GB, Mexico/General, Pacific/Wallis, Europe/Gibraltar, Africa/Conakry, Africa/Lubumbashi, Asia/Istanbul, America/Havana, NZ-CHAT, Asia/Choibalsan, America/Porto_Acre, Asia/Omsk, Europe/Vaduz, US/Michigan, Asia/Dhaka, America/Barbados, Europe/Tiraspol, Atlantic/Cape_Verde, Asia/Yekaterinburg, America/Louisville, Pacific/Johnston, Pacific/Chatham, Europe/Ljubljana, America/Sao_Paulo, Asia/Jayapura, America/Curacao, Asia/Dushanbe, America/Guyana, America/Guayaquil, America/Martinique, Portugal, Europe/Berlin, Europe/Moscow, Europe/Chisinau, America/Puerto_Rico, America/Rankin_Inlet, Pacific/Ponape, Europe/Stockholm, Europe/Budapest, America/Argentina/Jujuy, Australia/Eucla, Asia/Shanghai, Universal, Europe/Zagreb, America/Port_of_Spain, Europe/Helsinki, Asia/Beirut, Asia/Tel_Aviv, Pacific/Bougainville, US/Central, Africa/Sao_Tome, Indian/Chagos, America/Cayenne, Asia/Yakutsk, Pacific/Galapagos, Australia/North, Europe/Paris, Africa/Ndjamena, Pacific/Fiji, America/Rainy_River, Indian/Maldives, Australia/Yancowinna, SystemV/AST4, Asia/Oral, America/Yellowknife, Pacific/Enderbury, America/Juneau, Australia/Victoria, America/Indiana/Vevay, Asia/Tashkent, Asia/Jakarta, Africa/Ceuta, Asia/Barnaul, America/Recife, America/Buenos_Aires, America/Noronha, America/Swift_Current, Australia/Adelaide, America/Metlakatla, Africa/Djibouti, America/Paramaribo, Asia/Qostanay, Europe/Simferopol, Europe/Sofia, Africa/Nouakchott, Europe/Prague, America/Indiana/Vincennes, Antarctica/Mawson, America/Kralendijk, Antarctica/Troll, Europe/Samara, Indian/Christmas, America/Antigua, Pacific/Gambier, America/Indianapolis, America/Inuvik, America/Iqaluit, Pacific/Funafuti, UTC, Antarctica/Macquarie, Canada/Pacific, America/Moncton, Africa/Gaborone, Pacific/Chuuk, Asia/Pyongyang, America/St_Vincent, Asia/Gaza, Etc/Universal, PST8PDT, Atlantic/Faeroe, Asia/Qyzylorda, Canada/Newfoundland, America/Kentucky/Louisville, America/Yakutat, Asia/Ho_Chi_Minh, Antarctica/Casey, Europe/Copenhagen, Africa/Asmara, Atlantic/Azores, Europe/Vienna, ROK, Pacific/Pitcairn, America/Mazatlan, Australia/Queensland, Pacific/Nauru, Europe/Tirane, Asia/Kolkata, SystemV/MST7, Australia/Canberra, MET, Australia/Broken_Hill, Europe/Riga, America/Dominica, Africa/Abidjan, America/Mendoza, America/Santarem, Kwajalein, America/Asuncion, Asia/Ulan_Bator, NZ, America/Boise, Australia/Currie, EST5EDT, Pacific/Guam, Pacific/Wake, Atlantic/Bermuda, America/Costa_Rica, America/Dawson, Asia/Chongqing, Eire, Europe/Amsterdam, America/Indiana/Knox, America/North_Dakota/Beulah, Africa/Accra, Atlantic/Faroe, Mexico/BajaNorte, America/Maceio, Etc/UCT, Pacific/Apia, GMT0, America/Atka, Pacific/Niue, Australia/Lord_Howe, Europe/Dublin, Pacific/Truk, MST7MDT, America/Monterrey, America/Nassau, America/Jamaica, Asia/Bishkek, America/Atikokan, Atlantic/Stanley, Australia/NSW, US/Hawaii, SystemV/CST6, Indian/Mahe, Asia/Aqtobe, America/Sitka, Asia/Vladivostok, Africa/Libreville, Africa/Maputo, Zulu, America/Kentucky/Monticello, Africa/El_Aaiun, Africa/Ouagadougou, America/Coral_Harbour, Pacific/Marquesas, Brazil/West, America/Aruba, America/North_Dakota/Center, America/Cayman, Asia/Ulaanbaatar, Asia/Baghdad, Europe/San_Marino, America/Indiana/Tell_City, America/Tijuana, Pacific/Saipan, SystemV/YST9, Africa/Douala, America/Chihuahua, America/Ojinaga, Asia/Hovd, America/Anchorage, Chile/EasterIsland, America/Halifax, Antarctica/Rothera, America/Indiana/Indianapolis, US/Mountain, Asia/Damascus, America/Argentina/San_Luis, America/Santiago, Asia/Baku, America/Argentina/Ushuaia, Atlantic/Reykjavik, Africa/Brazzaville, Africa/Porto-Novo, America/La_Paz, Antarctica/DumontDUrville, Asia/Taipei, Antarctica/South_Pole, Asia/Manila, Asia/Bangkok, Africa/Dar_es_Salaam, Poland, Atlantic/Madeira, Antarctica/Palmer, America/Thunder_Bay, Africa/Addis_Ababa, Asia/Yangon, Europe/Uzhgorod, Brazil/DeNoronha, Asia/Ashkhabad, Etc/Zulu, America/Indiana/Marengo, America/Creston, America/Punta_Arenas, America/Mexico_City, Antarctica/Vostok, Asia/Jerusalem, Europe/Andorra, US/Samoa, PRC, Asia/Vientiane, Pacific/Kiritimati, America/Matamoros, America/Blanc-Sablon, Asia/Riyadh, Iceland, Pacific/Pohnpei, Asia/Ujung_Pandang, Atlantic/South_Georgia, Europe/Lisbon, Asia/Harbin, Europe/Oslo, Asia/Novokuznetsk, CST6CDT, Atlantic/Canary, America/Knox_IN, Asia/Kuwait, SystemV/HST10, Pacific/Efate, Africa/Lome, America/Bogota, America/Menominee, America/Adak, Pacific/Norfolk, Europe/Kirov, America/Resolute, Pacific/Tarawa, Africa/Kampala, Asia/Krasnoyarsk, Greenwich, SystemV/EST5, America/Edmonton, Europe/Podgorica, Australia/South, Canada/Central, Africa/Bujumbura, America/Santo_Domingo, US/Eastern, Europe/Minsk, Pacific/Auckland, Africa/Casablanca, America/Glace_Bay, Canada/Eastern, Asia/Qatar, Europe/Kiev, Singapore, Asia/Magadan, SystemV/PST8, America/Port-au-Prince, Europe/Belfast, America/St_Barthelemy, Asia/Ashgabat, Africa/Luanda, America/Nipigon, Atlantic/Jan_Mayen, Brazil/Acre, Asia/Muscat, Asia/Bahrain, Europe/Vilnius, America/Fortaleza, Etc/GMT0, US/East-Indiana, America/Hermosillo, America/Cancun, Africa/Maseru, Pacific/Kosrae, Africa/Kinshasa, Asia/Kathmandu, Asia/Seoul, Australia/Sydney, America/Lima, Australia/LHI, America/St_Lucia, Europe/Madrid, America/Bahia_Banderas, America/Montserrat, Asia/Brunei, America/Santa_Isabel, Canada/Mountain, America/Cambridge_Bay, Asia/Colombo, Australia/West, Indian/Antananarivo, Australia/Brisbane, Indian/Mayotte, US/Indiana-Starke, Asia/Urumqi, US/Aleutian, Europe/Volgograd, America/Lower_Princes, America/Vancouver, Africa/Blantyre, America/Rio_Branco, America/Danmarkshavn, America/Detroit, America/Thule, Africa/Lusaka, Asia/Hong_Kong, Iran, America/Argentina/La_Rioja, Africa/Dakar, SystemV/CST6CDT, America/Tortola, America/Porto_Velho, Asia/Sakhalin, Etc/GMT+10, America/Scoresbysund, Asia/Kamchatka, Asia/Thimbu, Africa/Harare, Etc/GMT+12, Etc/GMT+11, Navajo, America/Nome, Europe/Tallinn, Turkey, Africa/Khartoum, Africa/Johannesburg, Africa/Bangui, Europe/Belgrade, Jamaica, Africa/Bissau, Asia/Tehran, WET, Europe/Astrakhan, Africa/Juba, America/Campo_Grande, America/Belem, Etc/Greenwich, Asia/Saigon, America/Ensenada, Pacific/Midway, America/Jujuy, Africa/Timbuktu, America/Bahia, America/Goose_Bay, America/Virgin, America/Pangnirtung, Asia/Katmandu, America/Phoenix, Africa/Niamey, America/Whitehorse, Pacific/Noumea, Asia/Tbilisi, America/Montreal, Asia/Makassar, America/Argentina/San_Juan, Hongkong, UCT, Asia/Nicosia, America/Indiana/Winamac, SystemV/MST7MDT, America/Argentina/ComodRivadavia, America/Boa_Vista, America/Grenada, Asia/Atyrau, Australia/Darwin, Asia/Khandyga, Asia/Kuala_Lumpur, Asia/Famagusta, Asia/Thimphu, Asia/Rangoon, Europe/Bratislava, Asia/Calcutta, America/Argentina/Tucuman, Asia/Kabul, Indian/Cocos, Japan, Pacific/Tongatapu, America/New_York, Etc/GMT-12, Etc/GMT-11, Etc/GMT-10, SystemV/YST9YDT, Europe/Ulyanovsk, Etc/GMT-14, Etc/GMT-13, W-SU, America/Merida, EET, America/Rosario, Canada/Saskatchewan, America/St_Kitts, Arctic/Longyearbyen, America/Fort_Nelson, America/Caracas, America/Guadeloupe, Asia/Hebron, Indian/Kerguelen, SystemV/PST8PDT, Africa/Monrovia, Asia/Ust-Nera, Egypt, Asia/Srednekolymsk, America/North_Dakota/New_Salem, Asia/Anadyr, Australia/Melbourne, Asia/Irkutsk, America/Shiprock, America/Winnipeg, Europe/Vatican, Asia/Amman, Etc/UTC, SystemV/AST4ADT, Asia/Tokyo, America/Toronto, Asia/Singapore, Australia/Lindeman, America/Los_Angeles, SystemV/EST5EDT, Pacific/Majuro, America/Argentina/Buenos_Aires, Europe/Nicosia, Pacific/Guadalcanal, Europe/Athens, US/Pacific, Europe/Monaco]</span><br><span class="line">zonedDateTime: 2021-10-05T20:42:09.993+08:00[Asia/Shanghai]</span><br><span class="line">offsetDateTime: 2021-10-05T20:42:09.993+09:00</span><br></pre></td></tr></table></figure></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://lw900925.github.io/java/java8-newtime-api.html">Java 8新特性（四）：新的时间和日期API</a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>var options;"undefined"!=typeof lightGallery&&(options={selector:".gallery-item"},lightGallery(document.getElementsByClassName(".article-gallery")[0],options))</script></div></article><div class="blog-post-comments"><div id="disqus_thread"><noscript>加载评论需要在浏览器启用 JavaScript 脚本支持。</noscript></div></div><div id="footer-post-container"><div id="footer-post"><div id="nav-footer" style="display:none"><ul><li><a href="/">首页</a></li><li><a href="/archives/">文章</a></li><li><a href="/categories/">分类</a></li><li><a href="/search/">搜索</a></li><li><a href="/about/">关于</a></li></ul></div><div id="toc-footer" style="display:none"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JDK1-8%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">1.</span> <span class="toc-text">JDK1.8新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#lambda"><span class="toc-number">1.1.</span> <span class="toc-text">lambda</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java8%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.1.1.</span> <span class="toc-text">Java8中常用的函数式接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%E4%BD%BF%E7%94%A8%E4%BE%8B%E5%AD%90"><span class="toc-number">1.1.2.</span> <span class="toc-text">函数式接口使用例子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Stream-API"><span class="toc-number">1.2.</span> <span class="toc-text">Stream API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B5%81%EF%BC%9F"><span class="toc-number">1.2.1.</span> <span class="toc-text">什么是流？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">1.2.2.</span> <span class="toc-text">流的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%9A%84%E6%93%8D%E4%BD%9C%E5%88%86%E7%B1%BB"><span class="toc-number">1.2.3.</span> <span class="toc-text">流的操作分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%9A%84%E6%93%8D%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="toc-number">1.2.4.</span> <span class="toc-text">流的操作过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E6%B5%81%EF%BC%9F"><span class="toc-number">1.2.5.</span> <span class="toc-text">如何获取流？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E9%97%B4%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.6.</span> <span class="toc-text">中间操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%88%E7%AB%AF%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.7.</span> <span class="toc-text">终端操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B2%E6%8E%89%E7%A9%BA%E6%8C%87%E9%92%88%E4%B9%8BOptional"><span class="toc-number">1.3.</span> <span class="toc-text">干掉空指针之Optional</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B0%E7%9A%84%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4API"><span class="toc-number">1.4.</span> <span class="toc-text">新的日期时间API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E7%B1%BB"><span class="toc-number">1.4.1.</span> <span class="toc-text">常用的日期时间类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E6%93%8D%E4%BD%9C%E5%92%8C%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="toc-number">1.4.2.</span> <span class="toc-text">日期操作和格式化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E5%8C%BA"><span class="toc-number">1.4.3.</span> <span class="toc-text">时区</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">1.5.</span> <span class="toc-text">参考资料</span></a></li></ol></li></ol></div><div id="share-footer" style="display:none"><ul><li><a class="icon" target="_blank" rel="noopener external nofollow noreferrer" href="http://www.facebook.com/sharer.php?u=https://www.powercheng.fun/articles/d111bf74/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener external nofollow noreferrer" href="https://twitter.com/share?url=https://www.powercheng.fun/articles/d111bf74/&text=JDK1.8新特性"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener external nofollow noreferrer" href="http://www.linkedin.com/shareArticle?url=https://www.powercheng.fun/articles/d111bf74/&title=JDK1.8新特性"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener external nofollow noreferrer" href="https://pinterest.com/pin/create/bookmarklet/?url=https://www.powercheng.fun/articles/d111bf74/&is_video=false&description=JDK1.8新特性"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=JDK1.8新特性&body=Check out this article: https://www.powercheng.fun/articles/d111bf74/" rel="external nofollow noreferrer"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener external nofollow noreferrer" href="https://getpocket.com/save?url=https://www.powercheng.fun/articles/d111bf74/&title=JDK1.8新特性"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener external nofollow noreferrer" href="http://reddit.com/submit?url=https://www.powercheng.fun/articles/d111bf74/&title=JDK1.8新特性"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener external nofollow noreferrer" href="http://www.stumbleupon.com/submit?url=https://www.powercheng.fun/articles/d111bf74/&title=JDK1.8新特性"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener external nofollow noreferrer" href="http://digg.com/submit?url=https://www.powercheng.fun/articles/d111bf74/&title=JDK1.8新特性"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" href="http://www.tumblr.com/share/link?url=https://www.powercheng.fun/articles/d111bf74/&name=JDK1.8新特性&description=&lt;link rel=&#34;stylesheet&#34; type=&#34;text/css&#34; href=&#34;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&#34; /&gt;&lt;div class=&#34;.article-gallery&#34;&gt;&lt;p&gt;关于lambda表达式、streamAPI、Optional和新的日期时间API的总结&lt;/p&gt;"><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener external nofollow noreferrer" href="https://news.ycombinator.com/submitlink?u=https://www.powercheng.fun/articles/d111bf74/&t=JDK1.8新特性"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li></ul></div><div id="actions-footer"><a id="menu" class="icon" href="#" onclick='return $("#nav-footer").toggle(),!1'><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> 菜单</a> <a id="toc" class="icon" href="#" onclick='return $("#toc-footer").toggle(),!1'><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> 目录</a> <a id="share" class="icon" href="#" onclick='return $("#share-footer").toggle(),!1'><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a> <a id="top" style="display:none" class="icon" href="#" onclick='$("html, body").animate({scrollTop:0},"fast")'><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a></div></div></div><footer id="footer"><div class="footer-left">Copyright &copy; 2021-2025 Caiden Hou</div><div class="footer-right"><nav><ul><li><a href="/">首页</a></li><li><a href="/archives/">文章</a></li><li><a href="/categories/">分类</a></li><li><a href="/search/">搜索</a></li><li><a href="/about/">关于</a></li></ul></nav></div></footer></div><link rel="preload" href="/lib/font-awesome/css/all.min.css" as="style" onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"></noscript><script src="/lib/jquery/jquery.min.js"></script><script src="/lib/clipboard/clipboard.min.js"></script><script type="text/javascript">$(function(){$(".highlight table").before('<span class="btn-copy tooltipped tooltipped-sw" aria-label="复制到粘贴板！"><i class="fa-regular fa-clone"></i></span>'),new ClipboardJS(".btn-copy",{text:function(e){return Array.from(e.nextElementSibling.querySelectorAll(".code")).reduce((e,t)=>e+t.innerText+"\n","")}}).on("success",function(e){e.trigger.setAttribute("aria-label","复制成功！"),e.clearSelection()})})</script><script src="/js/main.js"></script><script type="text/javascript">var disqus_shortname="caidens-blog";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}()</script></body></html>