<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5"><meta name="description" content="主要是对NIO各个组成部分进行介绍和简单使用"><meta property="og:type" content="article"><meta property="og:title" content="NIO介绍及API使用"><meta property="og:url" content="https://www.powercheng.fun/articles/90a06e8/index.html"><meta property="og:site_name" content="Caiden&#39;s Blog"><meta property="og:description" content="主要是对NIO各个组成部分进行介绍和简单使用"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.powercheng.fun/articles/90a06e8/1C21172b1fimage-20211101092708772.png"><meta property="og:image" content="https://www.powercheng.fun/articles/90a06e8/1bc97C8912image-20211101092727138.png"><meta property="og:image" content="https://www.powercheng.fun/articles/90a06e8/c1Ea06CCA7image-20211101092743590.png"><meta property="og:image" content="https://www.powercheng.fun/articles/90a06e8/B251A2a3Dfimage-20211101092808090.png"><meta property="og:image" content="https://www.powercheng.fun/articles/90a06e8/1D3bCfDE12image-20211101092826038.png"><meta property="og:image" content="https://www.powercheng.fun/articles/90a06e8/db6FeE6765image-20211101092840867.png"><meta property="og:image" content="https://www.powercheng.fun/articles/90a06e8/65beabFfF3image-20211101092900425.png"><meta property="og:image" content="https://www.powercheng.fun/articles/90a06e8/98F51A151Dimage-20211101092916863.png"><meta property="og:image" content="https://www.powercheng.fun/articles/90a06e8/A21dEE6bF3image-20211101092934037.png"><meta property="og:image" content="https://www.powercheng.fun/articles/90a06e8/CfB7601eadimage-20211101093005234.png"><meta property="og:image" content="https://www.powercheng.fun/articles/90a06e8/9ABddAD7D9image-20211101093018850.png"><meta property="article:published_time" content="2021-11-01T00:59:58.000Z"><meta property="article:modified_time" content="2025-07-28T14:45:05.932Z"><meta property="article:author" content="Caiden Hou"><meta property="article:tag" content="NIO"><meta property="article:tag" content="网络编程"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://www.powercheng.fun/articles/90a06e8/1C21172b1fimage-20211101092708772.png"><link rel="shortcut icon" href="/images/favicon.ico"><link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="stylesheet" href="https://gw.alipayobjects.com/os/k/font/lxgwwenkaiscreenr.css"><title>NIO介绍及API使用</title><link rel="stylesheet" href="/css/style.css"><link rel="alternate" href="/true" title="Caiden&#39;s Blog" type="application/atom+xml"><meta name="generator" content="Hexo 5.4.0"></head><body class="max-width mx-auto px3 ltr"><div id="header-post"><a id="menu-icon" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" aria-label="顶部" onclick='$("html, body").animate({scrollTop:0},"fast")' style="display:none"><i class="fa-solid fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">首页</a></li><li><a href="/archives/">文章</a></li><li><a href="/categories/">分类</a></li><li><a href="/search/">搜索</a></li><li><a href="/about/">关于</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" aria-label="上一篇" href="/articles/2edfbfe8/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle()' onmouseout='$("#i-prev").toggle()'></i></a></li><li><a class="icon" aria-label="下一篇" href="/articles/faafedbd/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle()' onmouseout='$("#i-next").toggle()'></i></a></li><li><a class="icon" aria-label="返回顶部" href="#" onclick='$("html, body").animate({scrollTop:0},"fast")'><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle()' onmouseout='$("#i-top").toggle()'></i></a></li><li><a class="icon" aria-label="分享文章" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle()' onmouseout='$("#i-share").toggle()' onclick='return $("#share").toggle(),!1'></i></a></li></ul><span id="i-prev" class="info" style="display:none">上一篇</span> <span id="i-next" class="info" style="display:none">下一篇</span> <span id="i-top" class="info" style="display:none">返回顶部</span> <span id="i-share" class="info" style="display:none">分享文章</span></span><br><div id="share" style="display:none"><ul><li><a class="icon" target="_blank" rel="noopener external nofollow noreferrer" href="http://www.facebook.com/sharer.php?u=https://www.powercheng.fun/articles/90a06e8/"><i class="fab fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener external nofollow noreferrer" href="https://twitter.com/share?url=https://www.powercheng.fun/articles/90a06e8/&text=NIO介绍及API使用"><i class="fab fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener external nofollow noreferrer" href="http://www.linkedin.com/shareArticle?url=https://www.powercheng.fun/articles/90a06e8/&title=NIO介绍及API使用"><i class="fab fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener external nofollow noreferrer" href="https://pinterest.com/pin/create/bookmarklet/?url=https://www.powercheng.fun/articles/90a06e8/&is_video=false&description=NIO介绍及API使用"><i class="fab fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=NIO介绍及API使用&body=Check out this article: https://www.powercheng.fun/articles/90a06e8/" rel="external nofollow noreferrer"><i class="fa-solid fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener external nofollow noreferrer" href="https://getpocket.com/save?url=https://www.powercheng.fun/articles/90a06e8/&title=NIO介绍及API使用"><i class="fab fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener external nofollow noreferrer" href="http://reddit.com/submit?url=https://www.powercheng.fun/articles/90a06e8/&title=NIO介绍及API使用"><i class="fab fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener external nofollow noreferrer" href="http://www.stumbleupon.com/submit?url=https://www.powercheng.fun/articles/90a06e8/&title=NIO介绍及API使用"><i class="fab fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener external nofollow noreferrer" href="http://digg.com/submit?url=https://www.powercheng.fun/articles/90a06e8/&title=NIO介绍及API使用"><i class="fab fa-digg" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" href="http://www.tumblr.com/share/link?url=https://www.powercheng.fun/articles/90a06e8/&name=NIO介绍及API使用&description=&lt;link rel=&#34;stylesheet&#34; type=&#34;text/css&#34; href=&#34;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&#34; /&gt;&lt;div class=&#34;.article-gallery&#34;&gt;&lt;p&gt;主要是对NIO各个组成部分进行介绍和简单使用&lt;/p&gt;"><i class="fab fa-tumblr" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener external nofollow noreferrer" href="https://news.ycombinator.com/submitlink?u=https://www.powercheng.fun/articles/90a06e8/&t=NIO介绍及API使用"><i class="fab fa-hacker-news" aria-hidden="true"></i></a></li></ul></div><div id="toc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%BB%E5%A1%9EIO%EF%BC%88BIO%EF%BC%89"><span class="toc-number">1.1.</span> <span class="toc-text">阻塞IO（BIO）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9EIO%EF%BC%88NIO%EF%BC%89TODO"><span class="toc-number">1.2.</span> <span class="toc-text">非阻塞IO（NIO）TODO</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NIO%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86"><span class="toc-number">1.3.</span> <span class="toc-text">NIO组成部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Channel"><span class="toc-number">1.3.1.</span> <span class="toc-text">Channel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Buffer"><span class="toc-number">1.3.2.</span> <span class="toc-text">Buffer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Selector"><span class="toc-number">1.3.3.</span> <span class="toc-text">Selector</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E4%B8%AA%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.3.4.</span> <span class="toc-text">三个组件之间的关系</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Channel-1"><span class="toc-number">2.</span> <span class="toc-text">Channel</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E7%9A%84Channel%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.1.</span> <span class="toc-text">重要的Channel实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#FileChannel%E4%BB%8B%E7%BB%8D%E5%92%8C%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.1.1.</span> <span class="toc-text">FileChannel介绍和示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SocketChannel%E4%BB%8B%E7%BB%8D%E5%92%8C%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.1.2.</span> <span class="toc-text">SocketChannel介绍和示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Buffer-1"><span class="toc-number">3.</span> <span class="toc-text">Buffer</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#buffer%E5%AE%9E%E9%99%85%E6%98%AF%E5%95%A5"><span class="toc-number">3.1.</span> <span class="toc-text">buffer实际是啥</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B6%E5%B1%82%E6%8A%BD%E8%B1%A1%E7%B1%BBBuffer%E7%B1%BB"><span class="toc-number">3.2.</span> <span class="toc-text">顶层抽象类Buffer类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#buffer%E5%B8%B8%E7%94%A8API"><span class="toc-number">3.3.</span> <span class="toc-text">buffer常用API</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ByteBuffer%E5%B8%B8%E7%94%A8API"><span class="toc-number">3.4.</span> <span class="toc-text">ByteBuffer常用API</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MappedByteBuffer"><span class="toc-number">3.5.</span> <span class="toc-text">MappedByteBuffer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%95%A3%E5%92%8C%E8%81%9A%E9%9B%86%EF%BC%88Scatter%E5%92%8CGather%EF%BC%89"><span class="toc-number">3.6.</span> <span class="toc-text">分散和聚集（Scatter和Gather）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Selector-1"><span class="toc-number">4.</span> <span class="toc-text">Selector</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="toc-number">4.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E7%82%B9%E8%AF%B4%E6%98%8E"><span class="toc-number">4.2.</span> <span class="toc-text">特点说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">4.3.</span> <span class="toc-text">运行过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E4%BD%BF%E7%94%A8"><span class="toc-number">4.4.</span> <span class="toc-text">具体使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SelectionKey%E7%9B%B8%E5%85%B3API"><span class="toc-number">4.5.</span> <span class="toc-text">SelectionKey相关API</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#BUG"><span class="toc-number">5.</span> <span class="toc-text">BUG</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#nio%E7%A9%BA%E8%BD%AE%E8%AF%A2bug"><span class="toc-number">5.1.</span> <span class="toc-text">nio空轮询bug</span></a></li></ol></li></ol></div></span></div><div class="content index py4"><article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle p-name" itemprop="name headline">NIO介绍及API使用</h1><div class="meta"><div class="postdate"><time datetime="2021-11-01T00:59:58.000Z" class="dt-published" itemprop="datePublished">2021-11-01</time> (Updated: <time datetime="2025-07-28T14:45:05.932Z" class="dt-updated" itemprop="dateModified">2025-07-28</time>)</div><div class="article-category"><i class="fa-solid fa-archive"></i> <a class="category-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a></div><div class="article-tag"><i class="fa-solid fa-tag"></i> <a class="p-category" href="/tags/NIO/" rel="tag">NIO</a>, <a class="p-category" href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" rel="tag">网络编程</a></div></div></header><div class="content e-content" itemprop="articleBody"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery"><p>主要是对NIO各个组成部分进行介绍和简单使用</p><span id="more"></span><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Java NIO(New IO 或 Non Blocking IO) 是从Java1.4版本开始引入的一个新的IO API，可以替代标准的Java IO API，NIO支持面向缓冲区的、基于通道的IO操作。NIO将以更高效的方式进行文件的读写操作。</p><h2 id="阻塞IO（BIO）"><a href="#阻塞IO（BIO）" class="headerlink" title="阻塞IO（BIO）"></a>阻塞IO（BIO）</h2><p>阻塞IO也就是同步IO，如果进行读写操作，代码会一直阻塞，直到读取完成或写入完成，传统的解决方式是使用多线程来处理，但是及其消耗服务器资源，而且线程池线程数也是有限的，如果只能开100个线程，试想一种场景，100个客户端都在下载一个大文件，然而第101个请求来了，只请求一个几十kb的网页，但是也得等有空闲线程才可以，所以也是无法处理这个请求的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">使用BIO实现简单服务器</span><br><span class="line">使用多个telnet <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">8888</span></span><br><span class="line">ctrl + ] &gt; send message进行发送消息</span><br><span class="line">单线程测试：一次只能处理一个请求，只有那个连接关闭，才可以处理下一个连接请求</span><br><span class="line">多线程测试：可以处理多个，但是线程资源有限，处理请求数依然不乐观</span><br></pre></td></tr></table></figure><ul><li><p>BIO实现简单服务器，来一个请求开一个线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">voidmain</span><span class="params">(String[]args)</span>throwsIOException</span>&#123;</span><br><span class="line">ServerSocket serverSocket =newServerSocket(<span class="number">8888</span>);</span><br><span class="line">    ThreadPoolExecutor threadPoolExecutor =newThreadPoolExecutor(<span class="number">10</span>, <span class="number">20</span>, <span class="number">5</span>,</span><br><span class="line">            TimeUnit.SECONDS,newLinkedBlockingDeque&lt;&gt;(), Executors.defaultThreadFactory(),newThreadPoolExecutor.AbortPolicy());</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;等待连接...&quot;</span>);</span><br><span class="line">        <span class="comment">// 如果没有连接将会一直阻塞在accept</span></span><br><span class="line">        Socket socket = serverSocket.accept();</span><br><span class="line">        <span class="comment">// 如果可以运行到这一行，证明不再是在accept阻塞了，也就是有连接进来了</span></span><br><span class="line">        System.out.println(<span class="string">&quot;有客户端连接了！&quot;</span>);</span><br><span class="line">        <span class="comment">// 有连接后，main线程把连接交给线程池中的一个线程去处理，main继续等待连接...</span></span><br><span class="line">        threadPoolExecutor.execute(()-&gt;handler(socket));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *读取已连接的Socket数据</span></span><br><span class="line"><span class="comment">*<span class="doctag">@paramsocketsocket</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="title">voidhandler</span><span class="params">(Socket socket)</span></span>&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;当前线程：&quot;</span> + Thread.currentThread().getName()</span><br><span class="line">+ <span class="string">&quot;处理客户端请求，客户端地址：&quot;</span> + socket.getRemoteSocketAddress());</span><br><span class="line"><span class="keyword">byte</span>[]bytes =<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        InputStream inputStream = socket.getInputStream();</span><br><span class="line">intlength;</span><br><span class="line"><span class="keyword">while</span>((length = inputStream.read(bytes))!= -<span class="number">1</span>) &#123;</span><br><span class="line">System.out.println(newString(bytes, <span class="number">0</span>, length));</span><br><span class="line">&#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">socket.close();</span><br><span class="line">            System.out.println(<span class="string">&quot;连接关闭，客户端地址为：&quot;</span> + socket.getRemoteSocketAddress());</span><br><span class="line">&#125;<span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="非阻塞IO（NIO）TODO"><a href="#非阻塞IO（NIO）TODO" class="headerlink" title="非阻塞IO（NIO）TODO"></a>非阻塞IO（NIO）TODO</h2><p>可以用一个线程，处理多个客户端的连接</p><h2 id="NIO组成部分"><a href="#NIO组成部分" class="headerlink" title="NIO组成部分"></a>NIO组成部分</h2><p>由以下几个核心部分组成</p><ul><li>Channels</li><li>Buffers</li><li>Selectors</li></ul><p>这三个构成了核心API，还有其他组件如Pipe和FileLock，只不过是三个核心组件共同使用的工具类</p><h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p>可以翻译成通道，可以和IO中的Stream流对比着理解，传统IO中的流是单向的，但是Channel是双向的，既可以读也可以写。</p><p>NIO中的Channel主要实现有FileChannel、DatagramChannel、SocketChannel和ServerSocketChannel，分别对应文件IO、UDP和TCP（client和server）IO</p><h3 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h3><p>NIO 中的关键 Buffer 实现有：ByteBuffer, CharBuffer, DoubleBuffer, FloatBuffer,<br>IntBuffer, LongBuffer, ShortBuffer，分别对应基本数据类型: byte, char, double,<br>float, int, long, short。</p><h3 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3><p>Selector 运行单线程处理多个 Channel，如果你的应用打开了多个通道，但每个连接<br>的流量都很低，使用 Selector 就会很方便。例如在一个聊天服务器中。要使用<br>Selector, 得向 Selector 注册 Channel，然后调用它的 select()方法。这个方法会一直<br>阻塞到某个注册的通道有事件就绪。一旦这个方法返回，线程就可以处理这些事件，<br>事件的例子有如新的连接进来、数据接收等。</p><h3 id="三个组件之间的关系"><a href="#三个组件之间的关系" class="headerlink" title="三个组件之间的关系"></a>三个组件之间的关系</h3><p>先上图</p><a href="/articles/90a06e8/1C21172b1fimage-20211101092708772.png" class="gallery-item"><img src="/articles/90a06e8/1C21172b1fimage-20211101092708772.png" title="image-20211101092708772"></a><p>关系图说明：</p><ol><li>每个Channel都会对应一个Buffer</li><li>Selector对应一个线程，一个线程对应多个Channel(连接)</li><li>该图反应了有三个channel注册到该selector程序</li><li>程序切换到哪个channel是由事件决定的，Event就是一个重要概念，具体事件是啥意思？可以类比前端中的点击事件onClick，这里的事件可以是网络连接，数据读取</li><li>selector会根据不同的事件，在各个通道上切换</li><li>buffer就是一个内存块，底层就是一个数组</li><li>数据的读取和写入都是通过Buffer来的，这个和BIO中的不一样，BIO中要么是输入流，要么是输出流，不能双向，但是NIO的Buffer是可以读也可以写，但是需要flip方法切换模式</li><li>channel是双向的，可以返回底层操作系统的情况，比如Linux，底层操作系统的通道就是双向的</li></ol><h1 id="Channel-1"><a href="#Channel-1" class="headerlink" title="Channel"></a>Channel</h1><p>channel是基于流实现的，比如说创建一个输出流，才能创建channel，到时候数据也都是在这个输出流的channel里面</p><p>通道和传统的IO流还是有区别的：</p><ul><li>既可以从通道中读取数据，又可以往通道里写数据</li><li>通道可以异步读写</li><li>通道中的数据总是要先读取到一个Buffer中、或者从一个Buffer中写入</li></ul><a href="/articles/90a06e8/1bc97C8912image-20211101092727138.png" class="gallery-item"><img src="/articles/90a06e8/1bc97C8912image-20211101092727138.png" title="image-20211101092727138"></a><h2 id="重要的Channel实现"><a href="#重要的Channel实现" class="headerlink" title="重要的Channel实现"></a>重要的Channel实现</h2><ul><li>FileChannel：文件IO</li><li>DatagramChannel：通过UDP读取网络中的数据</li><li>SocketChannel：通过TCP读取网络中的数据</li><li>ServerSocketChannel：可以监听新进来的TCP连接，像web服务器那样，对每一个新进来的连接都会创建一个SocketChannel</li></ul><p>通道覆盖了文件IO和网络IO，牛比！</p><h3 id="FileChannel介绍和示例"><a href="#FileChannel介绍和示例" class="headerlink" title="FileChannel介绍和示例"></a>FileChannel介绍和示例</h3><p>API概述：</p><a href="/articles/90a06e8/c1Ea06CCA7image-20211101092743590.png" class="gallery-item"><img src="/articles/90a06e8/c1Ea06CCA7image-20211101092743590.png" title="image-20211101092743590"></a><ul><li><p>使用FileChannel读取数据到Buffer中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        RandomAccessFile randomAccessFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;d:\\hello.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        FileChannel channel = randomAccessFile.getChannel();</span><br><span class="line">        <span class="comment">// 接收数据的Buffer</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">        <span class="keyword">int</span> read = channel.read(buffer);</span><br><span class="line">        <span class="keyword">while</span> (read != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;读取了：&quot;</span> + read);</span><br><span class="line">            <span class="comment">// 将缓存字节数组的指针设置为数组的开始序列即数组下标0。这样就可以从buffer开头，对该buffer进行遍历（读取）了。</span></span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">                <span class="comment">// 读的字节转成字符，查看字符是否与文本一样</span></span><br><span class="line">                System.out.println((<span class="keyword">char</span>) buffer.get());</span><br><span class="line">            &#125;</span><br><span class="line">            buffer.clear();</span><br><span class="line">            <span class="comment">// 有可能一次没读完，继续读（就是文件大小字节数大于缓冲区设定的字节数的时候，需要接着读）</span></span><br><span class="line">            read = channel.read(buffer);</span><br><span class="line">        &#125;</span><br><span class="line">        channel.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;结束了！&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>使用FileChannel向文件中写入数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">channelWrite</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        RandomAccessFile randomAccessFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;d:\\hello.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        FileChannel channel = randomAccessFile.getChannel();</span><br><span class="line">        <span class="comment">// 把以下数据写入文件</span></span><br><span class="line">        String newData = <span class="string">&quot;write some words...&quot;</span> + System.currentTimeMillis();</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">        buffer.clear();</span><br><span class="line">        buffer.put(newData.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        buffer.flip();</span><br><span class="line">        <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">            channel.write(buffer);</span><br><span class="line">            System.out.println(<span class="string">&quot;已经写入...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        channel.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>FileChannel其他方法演示如position、size、truncate、force演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">otherFunction</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        RandomAccessFile randomAccessFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;d:\\hello.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        FileChannel channel = randomAccessFile.getChannel();</span><br><span class="line">        <span class="comment">// position，定到channel的特定位置来进行读取写入操作</span></span><br><span class="line">        <span class="comment">// position 设置在文件结束符之后，读取得话会返回-1，写入的话可以正常写入，但是会造成文件空洞，磁盘上物理文件写入的数据间有空隙</span></span><br><span class="line">        <span class="keyword">long</span> position = channel.position();</span><br><span class="line">        System.out.println(<span class="string">&quot;channel 当前位置：&quot;</span> + position);</span><br><span class="line">        channel.position(position + <span class="number">12</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;channel 改变位置：&quot;</span> + channel.position());</span><br><span class="line">        <span class="comment">// size() 获取该通道所关联文件的大小</span></span><br><span class="line">        System.out.println(<span class="string">&quot;channel所关联文件大小为：&quot;</span> + channel.size());</span><br><span class="line">        <span class="comment">// truncate() 方法，截取文件，下面的情况就是会把第20个字节之后的内容都删除</span></span><br><span class="line">        channel.truncate(<span class="number">20</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;截取后文件大小：&quot;</span> + channel.size());</span><br><span class="line">        <span class="comment">// force(boolean metaData) 可以类比为stream中的flush方法，把缓冲区的内容刷到磁盘上</span></span><br><span class="line">        <span class="comment">// 这个布尔类型的参数含义是是否将文件元数据（权限信息等）写入到磁盘</span></span><br><span class="line">        channel.force(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>通道间通信，transferFrom和transferTo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">transferData</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        RandomAccessFile aFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;d:\\hello.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        RandomAccessFile bFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;d:\\test.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        <span class="comment">// 将aFile中的内容复制到bFile中</span></span><br><span class="line">        FileChannel fromChannel = aFile.getChannel();</span><br><span class="line">        FileChannel toChannel = bFile.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// transferFrom，从目标channel传数据到当前channel</span></span><br><span class="line">        <span class="comment">// 从fromChannel的位置0，复制size个字节到toChannel中</span></span><br><span class="line">        toChannel.transferFrom(fromChannel, <span class="number">0</span>, fromChannel.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// transferTo，从当前Channel传数据到目标Channel中</span></span><br><span class="line">        RandomAccessFile cFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;d:\\c.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        FileChannel cFileChannel = cFile.getChannel();</span><br><span class="line">        fromChannel.transferTo(<span class="number">0</span>, fromChannel.size(), cFileChannel);</span><br><span class="line"></span><br><span class="line">        aFile.close();</span><br><span class="line">        bFile.close();</span><br><span class="line">        cFile.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;复制完成！&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="SocketChannel介绍和示例"><a href="#SocketChannel介绍和示例" class="headerlink" title="SocketChannel介绍和示例"></a>SocketChannel介绍和示例</h3><p>共有三种SocketChannel</p><ol><li>ServerSocketChannel：注意这个是没有读写操作的，主要作用就是用于监听一个端口，来了连接了就创建一个SocketChannel对象去处理连接请求</li><li>SocketChannel：基于TCP建立套接字连接</li><li>DatagramChannel：基于UDP进行读写网络数据</li></ol><p><strong>ServerSocketChannel</strong></p><p>下面是一段监听端口是否有连接的程序，有连接就打印远程连接的地址，无连接就打印null</p><p>注意非阻塞的使用</p><ul><li><p>具体代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">8888</span>;</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.wrap(<span class="string">&quot;hello,nio!&quot;</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line">        <span class="comment">// 设置模式非阻塞，如果设置为true得话，就会阻塞，也就是下面accept的时候，必须得有连接进来才会进行下面的if判断</span></span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;waiting for connections...&quot;</span>);</span><br><span class="line">            <span class="comment">// 如果设置成阻塞的话，没有连接的情况，就会一直阻塞到这一行，后面的代码也不会执行</span></span><br><span class="line">            SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">            <span class="keyword">if</span> (socketChannel == <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;null...&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;incoming connection from: &quot;</span> + socketChannel.getRemoteAddress());</span><br><span class="line">                <span class="comment">// 缓冲区指针指向0</span></span><br><span class="line">                buffer.rewind();</span><br><span class="line">                socketChannel.write(buffer);</span><br><span class="line">                socketChannel.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>SocketChannel</strong></p><p>下面是SocketChannel建立一段连接的程序</p><ul><li><p>SocketChannel建立连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用open(SocketAddress remote)</span></span><br><span class="line">        SocketChannel socketChannel = SocketChannel.open(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;www.baidu.com&quot;</span>, <span class="number">80</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方式二 使用connect</span></span><br><span class="line">        SocketChannel sc = SocketChannel.open();</span><br><span class="line">        sc.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;www.baidu.com&quot;</span>, <span class="number">80</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置非阻塞</span></span><br><span class="line">        socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        socketChannel.read(buffer);</span><br><span class="line">        socketChannel.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;read over!&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>DatagramChannel</strong></p><h1 id="Buffer-1"><a href="#Buffer-1" class="headerlink" title="Buffer"></a>Buffer</h1><h2 id="buffer实际是啥"><a href="#buffer实际是啥" class="headerlink" title="buffer实际是啥"></a>buffer实际是啥</h2><p>buffer底层就是维护着一个数组，如byteBuffer，就是维护一个byte[]</p><p>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">byte</span>[] hb;</span><br></pre></td></tr></table></figure><p>真正的数据其实就是存在这个数组里面了</p><p>buffer都有java基本类型的实现，想读啥样的数据，就选对应buffer即可</p><a href="/articles/90a06e8/B251A2a3Dfimage-20211101092808090.png" class="gallery-item"><img src="/articles/90a06e8/B251A2a3Dfimage-20211101092808090.png" title="image-20211101092808090"></a><p>其实ByteBuffer用的最多，因为在网络传输时，基本单位也都是用的字节</p><h2 id="顶层抽象类Buffer类"><a href="#顶层抽象类Buffer类" class="headerlink" title="顶层抽象类Buffer类"></a>顶层抽象类Buffer类</h2><p>定义了几个关键参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Invariants: mark &lt;= position &lt;= limit &lt;= capacity</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> position = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> limit;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br></pre></td></tr></table></figure><p>position：实时记录指针当前位置</p><p>limit：当前数组的数据大小，比如数组大小是10，只存了5个数据，limit就是5</p><p>capacity：数组容量，就是数组的实际大小，一旦确定不能修改</p><p>mark：标记？还没发现有啥用呢</p><h2 id="buffer常用API"><a href="#buffer常用API" class="headerlink" title="buffer常用API"></a>buffer常用API</h2><a href="/articles/90a06e8/1D3bCfDE12image-20211101092826038.png" class="gallery-item"><img src="/articles/90a06e8/1D3bCfDE12image-20211101092826038.png" title="image-20211101092826038"></a><h2 id="ByteBuffer常用API"><a href="#ByteBuffer常用API" class="headerlink" title="ByteBuffer常用API"></a>ByteBuffer常用API</h2><a href="/articles/90a06e8/db6FeE6765image-20211101092840867.png" class="gallery-item"><img src="/articles/90a06e8/db6FeE6765image-20211101092840867.png" title="image-20211101092840867"></a><h2 id="MappedByteBuffer"><a href="#MappedByteBuffer" class="headerlink" title="MappedByteBuffer"></a>MappedByteBuffer</h2><p>可以直接在内存中修改文件，没有尝试过，没见过，见过再说</p><h2 id="分散和聚集（Scatter和Gather）"><a href="#分散和聚集（Scatter和Gather）" class="headerlink" title="分散和聚集（Scatter和Gather）"></a>分散和聚集（Scatter和Gather）</h2><p>之前都是在一个Buffer中操作的，我们这里可以用多个buffer来操作</p><h1 id="Selector-1"><a href="#Selector-1" class="headerlink" title="Selector"></a>Selector</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>Selector能够检测多个注册的通道是否有事件发生（多个Channel以事件的方式可以注册到同一个Selector），如果有事件发生，便获取事件然后针对每一个事件进行相应的处理，这样就可以用一个线程去管理多个连接了！</p><a href="/articles/90a06e8/65beabFfF3image-20211101092900425.png" class="gallery-item"><img src="/articles/90a06e8/65beabFfF3image-20211101092900425.png" title="image-20211101092900425"></a><h2 id="特点说明"><a href="#特点说明" class="headerlink" title="特点说明"></a>特点说明</h2><a href="/articles/90a06e8/98F51A151Dimage-20211101092916863.png" class="gallery-item"><img src="/articles/90a06e8/98F51A151Dimage-20211101092916863.png" title="image-20211101092916863"></a><h2 id="运行过程"><a href="#运行过程" class="headerlink" title="运行过程"></a>运行过程</h2><a href="/articles/90a06e8/A21dEE6bF3image-20211101092934037.png" class="gallery-item"><img src="/articles/90a06e8/A21dEE6bF3image-20211101092934037.png" title="image-20211101092934037"></a><h2 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h2><ol><li>生成各种channel对象</li><li>然后使用channel.regiister(selector, op_accept)，第二个参数是各种事件，注册到selector中</li><li>然后selector.select(long timeout)，检查有没有事件发生，如果返回0，无事发生，其他就有事件了</li><li>然后获取selectionKeys，遍历这个集合，挨个查看每个key发生的是啥事件，是accept还是read还是啥的</li><li>然后根据key获取channel，也就是调用key.channel方法，然后根据实际情况进行强转为具体的channel，然后进行accept或者read操作或者其他操作</li></ol><ul><li><p>实际NIO写的服务器代码，服务端的作用就是监听有没有客户端连接，有了建立连接，如果客户端有发送（write）数据，就读取（read）并打印客户端发的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建serverSocketChannel来接收连接，生成socketChannel来处理连接</span></span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">6666</span>));</span><br><span class="line">        <span class="comment">// 创建selector对象</span></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 将serverSocketChannel注册到selector中去，进行事件(OP_ACCEPT)监听，有连接事件就操作</span></span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环等待客户端连接</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (selector.select(<span class="number">1000</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;服务器等待了一秒，服务器无事件发生...&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果有事件发生了，拿到selectionKeys</span></span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; keyIterator = selectionKeys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">                SelectionKey curKey = keyIterator.next();</span><br><span class="line">                <span class="comment">// 如果是OP_ACCEPT 客户端连接事件</span></span><br><span class="line">                <span class="keyword">if</span> (curKey.isAcceptable()) &#123;</span><br><span class="line">                    ServerSocketChannel channel = (ServerSocketChannel) curKey.channel();</span><br><span class="line">                    <span class="comment">// 接收连接生成SocketChannel，然后就可以进行进一步操作了，进一步操作是啥不管，把这个channel放入到selector管理</span></span><br><span class="line">                    SocketChannel socketChannel = channel.accept();</span><br><span class="line">                    System.out.println(<span class="string">&quot;有一个客户端连接成功！客户端地址：&quot;</span> + socketChannel.getRemoteAddress());</span><br><span class="line">                    socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                    <span class="comment">// 第三个参数目前含义不明，应该是放读取的数据的，就是这个socketChannel目前有一个专门属于自己的buffer来操作</span></span><br><span class="line">                    socketChannel.register(selector, SelectionKey.OP_READ, ByteBuffer.allocate(<span class="number">1024</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果是OP_READ事件</span></span><br><span class="line">                <span class="keyword">if</span> (curKey.isReadable()) &#123;</span><br><span class="line">                    SocketChannel channel = (SocketChannel) curKey.channel();</span><br><span class="line">                    <span class="comment">// 这个attachment就是获取register时的第三个参数buffer</span></span><br><span class="line">                    ByteBuffer buffer = (ByteBuffer) curKey.attachment();</span><br><span class="line">                    <span class="comment">// 是否需要对buffer进行clear，参数重置？</span></span><br><span class="line">                    buffer.clear();</span><br><span class="line">                    <span class="comment">// 读取到buffer中</span></span><br><span class="line">                    <span class="keyword">int</span> length = channel.read(buffer);</span><br><span class="line">                    System.out.println(<span class="string">&quot;read from 客户端(&quot;</span> + channel.getRemoteAddress() +<span class="string">&quot;): &quot;</span> + <span class="keyword">new</span> String(buffer.array(), <span class="number">0</span>, length));</span><br><span class="line">                &#125;</span><br><span class="line">                keyIterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>客户端代码，客户端的作用就是往服务端发消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">        socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        InetSocketAddress socketAddress = <span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6666</span>);</span><br><span class="line">        <span class="comment">// 连接不会阻塞</span></span><br><span class="line">        <span class="keyword">if</span> (!socketChannel.connect(socketAddress)) &#123;</span><br><span class="line">            <span class="comment">// 如果没连上还可以做其他事情</span></span><br><span class="line">            <span class="keyword">while</span> (!socketChannel.finishConnect()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;做其他事情...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 输入数据发送</span></span><br><span class="line">            Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">            String s = scanner.nextLine();</span><br><span class="line">            <span class="comment">// 如果连接成功就发送数据</span></span><br><span class="line">            <span class="comment">// 这个wrap其实就是封装了，创建指定大小，然后挨个put一系列操作，wrap返回的byteBuffer大小就是参数中字节数组的大小</span></span><br><span class="line">            ByteBuffer byteBuffer = ByteBuffer.wrap(s.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">            <span class="comment">// 发送数据，其实就是write</span></span><br><span class="line">            socketChannel.write(byteBuffer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><p>运行效果：</p><a href="/articles/90a06e8/CfB7601eadimage-20211101093005234.png" class="gallery-item"><img src="/articles/90a06e8/CfB7601eadimage-20211101093005234.png" title="image-20211101093005234"></a><h2 id="SelectionKey相关API"><a href="#SelectionKey相关API" class="headerlink" title="SelectionKey相关API"></a>SelectionKey相关API</h2><a href="/articles/90a06e8/9ABddAD7D9image-20211101093018850.png" class="gallery-item"><img src="/articles/90a06e8/9ABddAD7D9image-20211101093018850.png" title="image-20211101093018850"></a><h1 id="BUG"><a href="#BUG" class="headerlink" title="BUG"></a>BUG</h1><h2 id="nio空轮询bug"><a href="#nio空轮询bug" class="headerlink" title="nio空轮询bug"></a>nio空轮询bug</h2></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>var options;"undefined"!=typeof lightGallery&&(options={selector:".gallery-item"},lightGallery(document.getElementsByClassName(".article-gallery")[0],options))</script></div></article><div class="blog-post-comments"><div id="disqus_thread"><noscript>加载评论需要在浏览器启用 JavaScript 脚本支持。</noscript></div></div><div id="footer-post-container"><div id="footer-post"><div id="nav-footer" style="display:none"><ul><li><a href="/">首页</a></li><li><a href="/archives/">文章</a></li><li><a href="/categories/">分类</a></li><li><a href="/search/">搜索</a></li><li><a href="/about/">关于</a></li></ul></div><div id="toc-footer" style="display:none"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%BB%E5%A1%9EIO%EF%BC%88BIO%EF%BC%89"><span class="toc-number">1.1.</span> <span class="toc-text">阻塞IO（BIO）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9EIO%EF%BC%88NIO%EF%BC%89TODO"><span class="toc-number">1.2.</span> <span class="toc-text">非阻塞IO（NIO）TODO</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NIO%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86"><span class="toc-number">1.3.</span> <span class="toc-text">NIO组成部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Channel"><span class="toc-number">1.3.1.</span> <span class="toc-text">Channel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Buffer"><span class="toc-number">1.3.2.</span> <span class="toc-text">Buffer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Selector"><span class="toc-number">1.3.3.</span> <span class="toc-text">Selector</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E4%B8%AA%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.3.4.</span> <span class="toc-text">三个组件之间的关系</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Channel-1"><span class="toc-number">2.</span> <span class="toc-text">Channel</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E7%9A%84Channel%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.1.</span> <span class="toc-text">重要的Channel实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#FileChannel%E4%BB%8B%E7%BB%8D%E5%92%8C%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.1.1.</span> <span class="toc-text">FileChannel介绍和示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SocketChannel%E4%BB%8B%E7%BB%8D%E5%92%8C%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.1.2.</span> <span class="toc-text">SocketChannel介绍和示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Buffer-1"><span class="toc-number">3.</span> <span class="toc-text">Buffer</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#buffer%E5%AE%9E%E9%99%85%E6%98%AF%E5%95%A5"><span class="toc-number">3.1.</span> <span class="toc-text">buffer实际是啥</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B6%E5%B1%82%E6%8A%BD%E8%B1%A1%E7%B1%BBBuffer%E7%B1%BB"><span class="toc-number">3.2.</span> <span class="toc-text">顶层抽象类Buffer类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#buffer%E5%B8%B8%E7%94%A8API"><span class="toc-number">3.3.</span> <span class="toc-text">buffer常用API</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ByteBuffer%E5%B8%B8%E7%94%A8API"><span class="toc-number">3.4.</span> <span class="toc-text">ByteBuffer常用API</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MappedByteBuffer"><span class="toc-number">3.5.</span> <span class="toc-text">MappedByteBuffer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%95%A3%E5%92%8C%E8%81%9A%E9%9B%86%EF%BC%88Scatter%E5%92%8CGather%EF%BC%89"><span class="toc-number">3.6.</span> <span class="toc-text">分散和聚集（Scatter和Gather）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Selector-1"><span class="toc-number">4.</span> <span class="toc-text">Selector</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="toc-number">4.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E7%82%B9%E8%AF%B4%E6%98%8E"><span class="toc-number">4.2.</span> <span class="toc-text">特点说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">4.3.</span> <span class="toc-text">运行过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E4%BD%BF%E7%94%A8"><span class="toc-number">4.4.</span> <span class="toc-text">具体使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SelectionKey%E7%9B%B8%E5%85%B3API"><span class="toc-number">4.5.</span> <span class="toc-text">SelectionKey相关API</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#BUG"><span class="toc-number">5.</span> <span class="toc-text">BUG</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#nio%E7%A9%BA%E8%BD%AE%E8%AF%A2bug"><span class="toc-number">5.1.</span> <span class="toc-text">nio空轮询bug</span></a></li></ol></li></ol></div><div id="share-footer" style="display:none"><ul><li><a class="icon" target="_blank" rel="noopener external nofollow noreferrer" href="http://www.facebook.com/sharer.php?u=https://www.powercheng.fun/articles/90a06e8/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener external nofollow noreferrer" href="https://twitter.com/share?url=https://www.powercheng.fun/articles/90a06e8/&text=NIO介绍及API使用"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener external nofollow noreferrer" href="http://www.linkedin.com/shareArticle?url=https://www.powercheng.fun/articles/90a06e8/&title=NIO介绍及API使用"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener external nofollow noreferrer" href="https://pinterest.com/pin/create/bookmarklet/?url=https://www.powercheng.fun/articles/90a06e8/&is_video=false&description=NIO介绍及API使用"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=NIO介绍及API使用&body=Check out this article: https://www.powercheng.fun/articles/90a06e8/" rel="external nofollow noreferrer"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener external nofollow noreferrer" href="https://getpocket.com/save?url=https://www.powercheng.fun/articles/90a06e8/&title=NIO介绍及API使用"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener external nofollow noreferrer" href="http://reddit.com/submit?url=https://www.powercheng.fun/articles/90a06e8/&title=NIO介绍及API使用"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener external nofollow noreferrer" href="http://www.stumbleupon.com/submit?url=https://www.powercheng.fun/articles/90a06e8/&title=NIO介绍及API使用"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener external nofollow noreferrer" href="http://digg.com/submit?url=https://www.powercheng.fun/articles/90a06e8/&title=NIO介绍及API使用"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" href="http://www.tumblr.com/share/link?url=https://www.powercheng.fun/articles/90a06e8/&name=NIO介绍及API使用&description=&lt;link rel=&#34;stylesheet&#34; type=&#34;text/css&#34; href=&#34;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&#34; /&gt;&lt;div class=&#34;.article-gallery&#34;&gt;&lt;p&gt;主要是对NIO各个组成部分进行介绍和简单使用&lt;/p&gt;"><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener external nofollow noreferrer" href="https://news.ycombinator.com/submitlink?u=https://www.powercheng.fun/articles/90a06e8/&t=NIO介绍及API使用"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li></ul></div><div id="actions-footer"><a id="menu" class="icon" href="#" onclick='return $("#nav-footer").toggle(),!1'><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> 菜单</a> <a id="toc" class="icon" href="#" onclick='return $("#toc-footer").toggle(),!1'><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> 目录</a> <a id="share" class="icon" href="#" onclick='return $("#share-footer").toggle(),!1'><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a> <a id="top" style="display:none" class="icon" href="#" onclick='$("html, body").animate({scrollTop:0},"fast")'><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a></div></div></div><footer id="footer"><div class="footer-left">Copyright &copy; 2021-2025 Caiden Hou</div><div class="footer-right"><nav><ul><li><a href="/">首页</a></li><li><a href="/archives/">文章</a></li><li><a href="/categories/">分类</a></li><li><a href="/search/">搜索</a></li><li><a href="/about/">关于</a></li></ul></nav></div></footer></div><link rel="preload" href="/lib/font-awesome/css/all.min.css" as="style" onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"></noscript><script src="/lib/jquery/jquery.min.js"></script><script src="/lib/clipboard/clipboard.min.js"></script><script type="text/javascript">$(function(){$(".highlight table").before('<span class="btn-copy tooltipped tooltipped-sw" aria-label="复制到粘贴板！"><i class="fa-regular fa-clone"></i></span>'),new ClipboardJS(".btn-copy",{text:function(e){return Array.from(e.nextElementSibling.querySelectorAll(".code")).reduce((e,t)=>e+t.innerText+"\n","")}}).on("success",function(e){e.trigger.setAttribute("aria-label","复制成功！"),e.clearSelection()})})</script><script src="/js/main.js"></script><script type="text/javascript">var disqus_shortname="caidens-blog";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}()</script></body></html>